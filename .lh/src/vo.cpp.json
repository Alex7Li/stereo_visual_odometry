{
    "sourceFile": "src/vo.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 34,
            "patches": [
                {
                    "date": 1646257185848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1646259823863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -111,9 +111,9 @@\n   // --------------------------------\n   // https://github.com/hjamal3/stereo_visual_odometry/blob/main/src/feature.cpp\n   // --------------------------------\n \n-  void deleteUnmatchFeaturesCircle(\n+  void deleteFeaturesWithFailureStatus(\n       std::vector<cv::Point2f> & points0, std::vector<cv::Point2f> & points1,\n       std::vector<cv::Point2f> & points2, std::vector<cv::Point2f> & points3,\n       std::vector<cv::Point2f> & points4, std::vector<int> & ages,\n       const std::vector<uchar> & status_all) {\n@@ -180,9 +180,9 @@\n     for(int i = 0; i < status3.size(); i++) {\n       status_all[i] = status0[i] | status1[i] | status2[i] | status3[i];\n     }\n \n-    deleteUnmatchFeaturesCircle(points_l_0, points_r_0, points_r_1, points_l_1,\n+    deleteFeaturesWithFailureStatus(points_l_0, points_r_0, points_r_1, points_l_1,\n                                 points_l_0_return, current_features.ages, status_all);\n     for (int i = 0; i < current_features.ages.size(); ++i) {\n       current_features.ages[i] += 1;\n     }\n"
                },
                {
                    "date": 1646260342209,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,13 +144,13 @@\n       }\n     }\n   }\n \n-  void circularMatching(cv::Mat img_l_0, cv::Mat img_r_0, cv::Mat img_l_1,\n-                        cv::Mat img_r_1, std::vector<cv::Point2f> & points_l_0,\n-                        std::vector<cv::Point2f> & points_r_0,\n-                        std::vector<cv::Point2f> & points_l_1,\n-                        std::vector<cv::Point2f> & points_r_1,\n+  void circularMatching(cv::Mat img_0, cv::Mat img_1, cv::Mat img_l_1,\n+                        cv::Mat img_3, std::vector<cv::Point2f> & points_0,\n+                        std::vector<cv::Point2f> & points_1,\n+                        std::vector<cv::Point2f> & points_2,\n+                        std::vector<cv::Point2f> & points_3,\n                         std::vector<cv::Point2f> & points_l_0_return,\n                         FeatureSet & current_features) {\n     std::vector<float> err;\n \n@@ -164,25 +164,25 @@\n     std::vector<uchar> status2;\n     std::vector<uchar> status3;\n \n     // Sparse iterative version of the Lucas-Kanade optical flow in pyramids.\n-    calcOpticalFlowPyrLK(img_l_0, img_r_0, points_l_0, points_r_0, status0, err,\n+    calcOpticalFlowPyrLK(img_0, img_1, points_0, points_1, status0, err,\n                          winSize, 3, termcrit, 0, 0.001);\n-    calcOpticalFlowPyrLK(img_r_0, img_r_1, points_r_0, points_r_1, status1, err,\n+    calcOpticalFlowPyrLK(img_1, img_3, points_1, points_3, status1, err,\n                          winSize, 3, termcrit, 0, 0.001);\n-    calcOpticalFlowPyrLK(img_r_1, img_l_1, points_r_1, points_l_1, status2, err,\n+    calcOpticalFlowPyrLK(img_3, img_l_1, points_3, points_2, status2, err,\n                          winSize, 3, termcrit, 0, 0.001);\n-    calcOpticalFlowPyrLK(img_l_1, img_l_0, points_l_1, points_l_0_return,\n+    calcOpticalFlowPyrLK(img_l_1, img_0, points_2, points_l_0_return,\n                          status3, err, winSize, 3, termcrit, 0, 0.001);\n-    if (status3.size() != status0.size() or points_l_0.size() != points_l_0_return.size()) {\n+    if (status3.size() != status0.size() or points_0.size() != points_l_0_return.size()) {\n       cerr << \"Size of returned points was not correct!!\\n\";\n     }\n     std::vector<uchar> status_all;\n     for(int i = 0; i < status3.size(); i++) {\n       status_all[i] = status0[i] | status1[i] | status2[i] | status3[i];\n     }\n \n-    deleteFeaturesWithFailureStatus(points_l_0, points_r_0, points_r_1, points_l_1,\n+    deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n                                 points_l_0_return, current_features.ages, status_all);\n     for (int i = 0; i < current_features.ages.size(); ++i) {\n       current_features.ages[i] += 1;\n     }\n"
                },
                {
                    "date": 1646260352389,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -149,9 +149,9 @@\n                         cv::Mat img_3, std::vector<cv::Point2f> & points_0,\n                         std::vector<cv::Point2f> & points_1,\n                         std::vector<cv::Point2f> & points_2,\n                         std::vector<cv::Point2f> & points_3,\n-                        std::vector<cv::Point2f> & points_l_0_return,\n+                        std::vector<cv::Point2f> & points_0_return,\n                         FeatureSet & current_features) {\n     std::vector<float> err;\n \n     cv::Size winSize =\n@@ -170,20 +170,20 @@\n     calcOpticalFlowPyrLK(img_1, img_3, points_1, points_3, status1, err,\n                          winSize, 3, termcrit, 0, 0.001);\n     calcOpticalFlowPyrLK(img_3, img_l_1, points_3, points_2, status2, err,\n                          winSize, 3, termcrit, 0, 0.001);\n-    calcOpticalFlowPyrLK(img_l_1, img_0, points_2, points_l_0_return,\n+    calcOpticalFlowPyrLK(img_l_1, img_0, points_2, points_0_return,\n                          status3, err, winSize, 3, termcrit, 0, 0.001);\n-    if (status3.size() != status0.size() or points_0.size() != points_l_0_return.size()) {\n+    if (status3.size() != status0.size() or points_0.size() != points_0_return.size()) {\n       cerr << \"Size of returned points was not correct!!\\n\";\n     }\n     std::vector<uchar> status_all;\n     for(int i = 0; i < status3.size(); i++) {\n       status_all[i] = status0[i] | status1[i] | status2[i] | status3[i];\n     }\n \n     deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n-                                points_l_0_return, current_features.ages, status_all);\n+                                points_0_return, current_features.ages, status_all);\n     for (int i = 0; i < current_features.ages.size(); ++i) {\n       current_features.ages[i] += 1;\n     }\n   }\n"
                },
                {
                    "date": 1646260381758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,10 +144,10 @@\n       }\n     }\n   }\n \n-  void circularMatching(cv::Mat img_0, cv::Mat img_1, cv::Mat img_l_1,\n-                        cv::Mat img_3, std::vector<cv::Point2f> & points_0,\n+  void circularMatching(const cv::Mat img_0, const cv::Mat img_1, const cv::Mat img_2,\n+                        const cv::Mat img_3, std::vector<cv::Point2f> & points_0,\n                         std::vector<cv::Point2f> & points_1,\n                         std::vector<cv::Point2f> & points_2,\n                         std::vector<cv::Point2f> & points_3,\n                         std::vector<cv::Point2f> & points_0_return,\n@@ -168,11 +168,11 @@\n     calcOpticalFlowPyrLK(img_0, img_1, points_0, points_1, status0, err,\n                          winSize, 3, termcrit, 0, 0.001);\n     calcOpticalFlowPyrLK(img_1, img_3, points_1, points_3, status1, err,\n                          winSize, 3, termcrit, 0, 0.001);\n-    calcOpticalFlowPyrLK(img_3, img_l_1, points_3, points_2, status2, err,\n+    calcOpticalFlowPyrLK(img_3, img_2, points_3, points_2, status2, err,\n                          winSize, 3, termcrit, 0, 0.001);\n-    calcOpticalFlowPyrLK(img_l_1, img_0, points_2, points_0_return,\n+    calcOpticalFlowPyrLK(img_2, img_0, points_2, points_0_return,\n                          status3, err, winSize, 3, termcrit, 0, 0.001);\n     if (status3.size() != status0.size() or points_0.size() != points_0_return.size()) {\n       cerr << \"Size of returned points was not correct!!\\n\";\n     }\n"
                },
                {
                    "date": 1646260418811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -180,13 +180,8 @@\n     for(int i = 0; i < status3.size(); i++) {\n       status_all[i] = status0[i] | status1[i] | status2[i] | status3[i];\n     }\n \n-    deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n-                                points_0_return, current_features.ages, status_all);\n-    for (int i = 0; i < current_features.ages.size(); ++i) {\n-      current_features.ages[i] += 1;\n-    }\n   }\n \n \n   // --------------------------------\n@@ -333,8 +328,13 @@\n \n     circularMatching(imageLeft_t0, imageRight_t0, imageLeft_t1, imageRight_t1,\n                      pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1,\n                      pointsLeftReturn_t0, currentVOFeatures);\n+    deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n+                                points_0_return, current_features.ages, status_all);\n+    for (int i = 0; i < current_features.ages.size(); ++i) {\n+      current_features.ages[i] += 1;\n+    }\n \n     // Check if circled back points are in range of original points.\n     std::vector<bool> status = findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n"
                },
                {
                    "date": 1646260461616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -179,8 +179,13 @@\n     std::vector<uchar> status_all;\n     for(int i = 0; i < status3.size(); i++) {\n       status_all[i] = status0[i] | status1[i] | status2[i] | status3[i];\n     }\n+    deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n+                                points_0_return, current_features.ages, status_all);\n+    for (int i = 0; i < current_features.ages.size(); ++i) {\n+      current_features.ages[i] += 1;\n+    }\n \n   }\n \n \n"
                },
                {
                    "date": 1646260478141,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -179,13 +179,8 @@\n     std::vector<uchar> status_all;\n     for(int i = 0; i < status3.size(); i++) {\n       status_all[i] = status0[i] | status1[i] | status2[i] | status3[i];\n     }\n-    deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n-                                points_0_return, current_features.ages, status_all);\n-    for (int i = 0; i < current_features.ages.size(); ++i) {\n-      current_features.ages[i] += 1;\n-    }\n \n   }\n \n \n@@ -338,8 +333,13 @@\n                                 points_0_return, current_features.ages, status_all);\n     for (int i = 0; i < current_features.ages.size(); ++i) {\n       current_features.ages[i] += 1;\n     }\n+    deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n+                                points_0_return, current_features.ages, status_all);\n+    for (int i = 0; i < current_features.ages.size(); ++i) {\n+      current_features.ages[i] += 1;\n+    }\n \n     // Check if circled back points are in range of original points.\n     std::vector<bool> status = findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n"
                },
                {
                    "date": 1646260493051,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -329,10 +329,10 @@\n     circularMatching(imageLeft_t0, imageRight_t0, imageLeft_t1, imageRight_t1,\n                      pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1,\n                      pointsLeftReturn_t0, currentVOFeatures);\n     deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n-                                points_0_return, current_features.ages, status_all);\n-    for (int i = 0; i < current_features.ages.size(); ++i) {\n+                                points_0_return, currentVOFeatures.ages, status_all);\n+    for (int i = 0; i < currentVOFeatures.ages.size(); ++i) {\n       current_features.ages[i] += 1;\n     }\n     deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n                                 points_0_return, current_features.ages, status_all);\n"
                },
                {
                    "date": 1646260502949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -331,15 +331,10 @@\n                      pointsLeftReturn_t0, currentVOFeatures);\n     deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n                                 points_0_return, currentVOFeatures.ages, status_all);\n     for (int i = 0; i < currentVOFeatures.ages.size(); ++i) {\n-      current_features.ages[i] += 1;\n+      currentVOFeatures.ages[i] += 1;\n     }\n-    deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n-                                points_0_return, current_features.ages, status_all);\n-    for (int i = 0; i < current_features.ages.size(); ++i) {\n-      current_features.ages[i] += 1;\n-    }\n \n     // Check if circled back points are in range of original points.\n     std::vector<bool> status = findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n"
                },
                {
                    "date": 1646260519040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -328,9 +328,10 @@\n \n     circularMatching(imageLeft_t0, imageRight_t0, imageLeft_t1, imageRight_t1,\n                      pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1,\n                      pointsLeftReturn_t0, currentVOFeatures);\n-    deleteFeaturesWithFailureStatus(points_0, points_1, points_3, points_2,\n+    deleteFeaturesWithFailureStatus(\n+                     pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1, pointsLeftReturn_t0,\n                                 points_0_return, currentVOFeatures.ages, status_all);\n     for (int i = 0; i < currentVOFeatures.ages.size(); ++i) {\n       currentVOFeatures.ages[i] += 1;\n     }\n"
                },
                {
                    "date": 1646260524185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -330,9 +330,9 @@\n                      pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1,\n                      pointsLeftReturn_t0, currentVOFeatures);\n     deleteFeaturesWithFailureStatus(\n                      pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1, pointsLeftReturn_t0,\n-                                points_0_return, currentVOFeatures.ages, status_all);\n+                                currentVOFeatures.ages, status_all);\n     for (int i = 0; i < currentVOFeatures.ages.size(); ++i) {\n       currentVOFeatures.ages[i] += 1;\n     }\n \n"
                },
                {
                    "date": 1646260529914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -329,10 +329,10 @@\n     circularMatching(imageLeft_t0, imageRight_t0, imageLeft_t1, imageRight_t1,\n                      pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1,\n                      pointsLeftReturn_t0, currentVOFeatures);\n     deleteFeaturesWithFailureStatus(\n-                     pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1, pointsLeftReturn_t0,\n-                                currentVOFeatures.ages, status_all);\n+        pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1, pointsLeftReturn_t0,\n+        currentVOFeatures.ages, status_all);\n     for (int i = 0; i < currentVOFeatures.ages.size(); ++i) {\n       currentVOFeatures.ages[i] += 1;\n     }\n \n"
                },
                {
                    "date": 1646260535494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -328,8 +328,9 @@\n \n     circularMatching(imageLeft_t0, imageRight_t0, imageLeft_t1, imageRight_t1,\n                      pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1,\n                      pointsLeftReturn_t0, currentVOFeatures);\n+\n     deleteFeaturesWithFailureStatus(\n         pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1, pointsLeftReturn_t0,\n         currentVOFeatures.ages, status_all);\n     for (int i = 0; i < currentVOFeatures.ages.size(); ++i) {\n"
                },
                {
                    "date": 1646260559809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,9 +144,9 @@\n       }\n     }\n   }\n \n-  void circularMatching(const cv::Mat img_0, const cv::Mat img_1, const cv::Mat img_2,\n+  std::vector<uchar> circularMatching(const cv::Mat img_0, const cv::Mat img_1, const cv::Mat img_2,\n                         const cv::Mat img_3, std::vector<cv::Point2f> & points_0,\n                         std::vector<cv::Point2f> & points_1,\n                         std::vector<cv::Point2f> & points_2,\n                         std::vector<cv::Point2f> & points_3,\n"
                },
                {
                    "date": 1646260565884,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -179,9 +179,9 @@\n     std::vector<uchar> status_all;\n     for(int i = 0; i < status3.size(); i++) {\n       status_all[i] = status0[i] | status1[i] | status2[i] | status3[i];\n     }\n-\n+    return status_all;\n   }\n \n \n   // --------------------------------\n"
                },
                {
                    "date": 1646260808010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -325,9 +325,9 @@\n                       features_per_bucket);\n \n     pointsLeftT0 = currentVOFeatures.points;\n \n-    circularMatching(imageLeft_t0, imageRight_t0, imageLeft_t1, imageRight_t1,\n+    std::vector<uchar> status = circularMatching(imageLeft_t0, imageRight_t0, imageLeft_t1, imageRight_t1,\n                      pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1,\n                      pointsLeftReturn_t0, currentVOFeatures);\n \n     deleteFeaturesWithFailureStatus(\n"
                },
                {
                    "date": 1646260820656,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -325,9 +325,9 @@\n                       features_per_bucket);\n \n     pointsLeftT0 = currentVOFeatures.points;\n \n-    std::vector<uchar> status = circularMatching(imageLeft_t0, imageRight_t0, imageLeft_t1, imageRight_t1,\n+    std::vector<uchar> matchingStatus = circularMatching(imageLeft_t0, imageRight_t0, imageLeft_t1, imageRight_t1,\n                      pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1,\n                      pointsLeftReturn_t0, currentVOFeatures);\n \n     deleteFeaturesWithFailureStatus(\n"
                },
                {
                    "date": 1646260843933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -331,9 +331,9 @@\n                      pointsLeftReturn_t0, currentVOFeatures);\n \n     deleteFeaturesWithFailureStatus(\n         pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1, pointsLeftReturn_t0,\n-        currentVOFeatures.ages, status_all);\n+        currentVOFeatures.ages, matchingStatus);\n     for (int i = 0; i < currentVOFeatures.ages.size(); ++i) {\n       currentVOFeatures.ages[i] += 1;\n     }\n \n"
                },
                {
                    "date": 1646260915500,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -331,15 +331,16 @@\n                      pointsLeftReturn_t0, currentVOFeatures);\n \n     deleteFeaturesWithFailureStatus(\n         pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1, pointsLeftReturn_t0,\n-        currentVOFeatures.ages, matchingStatus);\n+        currentVOFeatures.ages, status_all);\n     for (int i = 0; i < currentVOFeatures.ages.size(); ++i) {\n       currentVOFeatures.ages[i] += 1;\n     }\n \n     // Check if circled back points are in range of original points.\n-    std::vector<bool> status = findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n+    std::vector<bool> status;\n+     findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n     removeInvalidPoints(pointsLeftT1, status);\n     removeInvalidPoints(pointsRightT0, status);\n     removeInvalidPoints(pointsRightT1, status);\n"
                },
                {
                    "date": 1646261165847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,9 +173,9 @@\n                          winSize, 3, termcrit, 0, 0.001);\n     calcOpticalFlowPyrLK(img_2, img_0, points_2, points_0_return,\n                          status3, err, winSize, 3, termcrit, 0, 0.001);\n     if (status3.size() != status0.size() or points_0.size() != points_0_return.size()) {\n-      cerr << \"Size of returned points was not correct!!\\n\";\n+      std::cerr << \"Size of returned points was not correct!!\\n\";\n     }\n     std::vector<uchar> status_all;\n     for(int i = 0; i < status3.size(); i++) {\n       status_all[i] = status0[i] | status1[i] | status2[i] | status3[i];\n@@ -338,9 +338,9 @@\n     }\n \n     // Check if circled back points are in range of original points.\n     std::vector<bool> status;\n-     findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n+    findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n     removeInvalidPoints(pointsLeftT1, status);\n     removeInvalidPoints(pointsRightT0, status);\n     removeInvalidPoints(pointsRightT1, status);\n"
                },
                {
                    "date": 1646261246444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -149,10 +149,9 @@\n                         const cv::Mat img_3, std::vector<cv::Point2f> & points_0,\n                         std::vector<cv::Point2f> & points_1,\n                         std::vector<cv::Point2f> & points_2,\n                         std::vector<cv::Point2f> & points_3,\n-                        std::vector<cv::Point2f> & points_0_return,\n-                        FeatureSet & current_features) {\n+                        std::vector<cv::Point2f> & points_0_return) {\n     std::vector<float> err;\n \n     cv::Size winSize =\n         cv::Size(20, 20); // Lucas-Kanade optical flow window size\n"
                },
                {
                    "date": 1646261387543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -268,9 +268,9 @@\n     }\n   }\n   void cameraToWorld(\n       const cv::Mat & cameraProjection,\n-      const std::vector<cv::Point2f> & cameraPoints, cv::Mat & worldPoints,\n+      const std::vector<cv::Point2f> & cameraPoints, const cv::Mat & worldPoints,\n       cv::Mat & rotation, cv::Mat & translation) {\n     // Calculate frame to frame transformation\n     cv::Mat distCoeffs = cv::Mat::zeros(4, 1, CV_64FC1);\n     cv::Mat rvec = cv::Mat::zeros(3, 1, CV_64FC1);\n"
                },
                {
                    "date": 1646262654067,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -337,8 +337,9 @@\n     }\n \n     // Check if circled back points are in range of original points.\n     std::vector<bool> status;\n+    // TODO: Shouldn't we be modifying age here? - Alex\n     findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n     removeInvalidPoints(pointsLeftT1, status);\n     removeInvalidPoints(pointsRightT0, status);\n"
                },
                {
                    "date": 1646262675537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -337,9 +337,9 @@\n     }\n \n     // Check if circled back points are in range of original points.\n     std::vector<bool> status;\n-    // TODO: Shouldn't we be modifying age here? - Alex\n+    // TODO: Shouldn't we be modifying ages here? - Alex\n     findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n     removeInvalidPoints(pointsLeftT1, status);\n     removeInvalidPoints(pointsRightT0, status);\n"
                },
                {
                    "date": 1646262884025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -337,9 +337,9 @@\n     }\n \n     // Check if circled back points are in range of original points.\n     std::vector<bool> status;\n-    // TODO: Shouldn't we be modifying ages here? - Alex\n+    // TODO: Shouldn't we be modifying currentVOFeatures and ages array here? - Alex\n     findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n     removeInvalidPoints(pointsLeftT1, status);\n     removeInvalidPoints(pointsRightT0, status);\n"
                },
                {
                    "date": 1646262891417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -337,9 +337,9 @@\n     }\n \n     // Check if circled back points are in range of original points.\n     std::vector<bool> status;\n-    // TODO: Shouldn't we be modifying currentVOFeatures and ages array here? - Alex\n+    // TODO: Shouldn't we be modifying currentVOFeatures and the ages array here as well? - Alex\n     findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n     removeInvalidPoints(pointsLeftT1, status);\n     removeInvalidPoints(pointsRightT0, status);\n"
                },
                {
                    "date": 1646262964444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -337,9 +337,10 @@\n     }\n \n     // Check if circled back points are in range of original points.\n     std::vector<bool> status;\n-    // TODO: Shouldn't we be modifying currentVOFeatures and the ages array here as well? - Alex\n+    // TODO: Shouldn't we be modifying currentVOFeatures and the ages array here as well?\n+    // (Can do this by using deleteFeaturesWithFailureStatus) - Alex\n     findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n     removeInvalidPoints(pointsLeftT1, status);\n     removeInvalidPoints(pointsRightT0, status);\n"
                },
                {
                    "date": 1646262970961,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -338,9 +338,9 @@\n \n     // Check if circled back points are in range of original points.\n     std::vector<bool> status;\n     // TODO: Shouldn't we be modifying currentVOFeatures and the ages array here as well?\n-    // (Can do this by using deleteFeaturesWithFailureStatus) - Alex\n+    // (Can do this by using deleteFeaturesWithFailureStatus instead) - Alex\n     findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n     removeInvalidPoints(pointsLeftT1, status);\n     removeInvalidPoints(pointsRightT0, status);\n"
                },
                {
                    "date": 1646263180615,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,9 @@\n     imageRightT1_ = imageRight;\n \n     std::vector<cv::Point2f> pointsLeftT0, pointsRightT0, pointsLeftT1,\n         pointsRightT1;\n-\n+    \n     matchingFeatures(imageLeftT0_, imageRightT0_, imageLeftT1_, imageRightT1_,\n                      currentVOFeatures, pointsLeftT0, pointsRightT0,\n                      pointsLeftT1, pointsRightT1);\n \n@@ -308,9 +308,12 @@\n       std::vector<cv::Point2f> &pointsRightT1) {\n     \n     std::vector<cv::Point2f> pointsLeftReturn_t0; // feature points to check\n                                                   // circular matching validation\n+\n     // Append new features with old features.\n+    // TODO (Alex): Shouldn't we modify currentVOFeatures to index into the t1 images\n+    // at some point in this method?\n     currentVOFeatures.appendFeaturesFromImage(imageLeft_t0);\n \n     // --------------------------------------------------------\n     // Feature tracking using KLT tracker, bucketing and circular matching.\n"
                },
                {
                    "date": 1646263197050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,9 +311,9 @@\n                                                   // circular matching validation\n \n     // Append new features with old features.\n     // TODO (Alex): Shouldn't we modify currentVOFeatures to index into the t1 images\n-    // at some point in this method?\n+    // at some point in this method? Otherwise, they will get outdated really fast.\n     currentVOFeatures.appendFeaturesFromImage(imageLeft_t0);\n \n     // --------------------------------------------------------\n     // Feature tracking using KLT tracker, bucketing and circular matching.\n"
                },
                {
                    "date": 1646263219920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -308,12 +308,12 @@\n       std::vector<cv::Point2f> &pointsRightT1) {\n     \n     std::vector<cv::Point2f> pointsLeftReturn_t0; // feature points to check\n                                                   // circular matching validation\n+    // TODO (Alex): Shouldn't we modify currentVOFeatures to index into the t1 images\n+    // at some point in this method? Otherwise, they will get outdated really fast.\n \n     // Append new features with old features.\n-    // TODO (Alex): Shouldn't we modify currentVOFeatures to index into the t1 images\n-    // at some point in this method? Otherwise, they will get outdated really fast.\n     currentVOFeatures.appendFeaturesFromImage(imageLeft_t0);\n \n     // --------------------------------------------------------\n     // Feature tracking using KLT tracker, bucketing and circular matching.\n"
                },
                {
                    "date": 1646263395713,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -252,9 +252,9 @@\n       } else {\n         status.push_back(true);\n       }\n     }\n-    return status\n+    return status;\n   }\n \n   void removeInvalidPoints(std::vector<cv::Point2f> & points,\n                            const std::vector<bool> &status) {\n"
                },
                {
                    "date": 1646263408149,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -339,12 +339,12 @@\n       currentVOFeatures.ages[i] += 1;\n     }\n \n     // Check if circled back points are in range of original points.\n-    std::vector<bool> status;\n+    ;\n     // TODO: Shouldn't we be modifying currentVOFeatures and the ages array here as well?\n     // (Can do this by using deleteFeaturesWithFailureStatus instead) - Alex\n-    findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n+    std::vector<bool> status = findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n     removeInvalidPoints(pointsLeftT1, status);\n     removeInvalidPoints(pointsRightT0, status);\n     removeInvalidPoints(pointsRightT1, status);\n"
                },
                {
                    "date": 1646263413881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -338,12 +338,11 @@\n     for (int i = 0; i < currentVOFeatures.ages.size(); ++i) {\n       currentVOFeatures.ages[i] += 1;\n     }\n \n-    // Check if circled back points are in range of original points.\n-    ;\n     // TODO: Shouldn't we be modifying currentVOFeatures and the ages array here as well?\n     // (Can do this by using deleteFeaturesWithFailureStatus instead) - Alex\n+    // Check if circled back points are in range of original points.\n     std::vector<bool> status = findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, 0);\n     removeInvalidPoints(pointsLeftT0, status);\n     removeInvalidPoints(pointsLeftT1, status);\n     removeInvalidPoints(pointsRightT0, status);\n"
                }
            ],
            "date": 1646257185848,
            "name": "Commit-0",
            "content": "/****************************************************************\n *\n * @file \t\tvo.cpp\n *\n * @brief \t\tThe Visual Odometry class being used for\n translation. The math can be found in Haidar Jamal's Thesis:\n *https://www.ri.cmu.edu/publications/localization-for-lunar-micro-rovers/\n *\n * @version \t1.0\n * @date \t\t02/09/2022\n *\n * @authors \tBen Kolligs, Alex Li\n * @author \t\tCarnegie Mellon University, Planetary Robotics Lab\n *\n ****************************************************************/\n#include \"vo.h\"\n\nnamespace visual_odometry {\nVisualOdometry::VisualOdometry(const cv::Mat leftCameraProjection,\n                               const cv::Mat rightCameraProjection) {\n  leftCameraProjection_ = leftCameraProjection;\n  rightCameraProjection_ = rightCameraProjection;\n}\n\nVisualOdometry::~VisualOdometry() {}\nvoid VisualOdometry::stereo_callback_(const cv::Mat &imageLeft,\n                                      const cv::Mat &imageRight) {\n    // Wait until we have at least two time steps of data\n    // to begin predicting the change in pose.\n    if (!frame_id) {\n      imageLeftT0_ = imageLeft;\n      imageRightT0_ = imageRight;\n      frame_id++;\n      return;\n    }\n\n    imageLeftT1_ = imageLeft;\n    imageRightT1_ = imageRight;\n\n    std::vector<cv::Point2f> pointsLeftT0, pointsRightT0, pointsLeftT1,\n        pointsRightT1;\n\n    matchingFeatures(imageLeftT0_, imageRightT0_, imageLeftT1_, imageRightT1_,\n                     currentVOFeatures, pointsLeftT0, pointsRightT0,\n                     pointsLeftT1, pointsRightT1);\n\n    // Set new images as old images.\n    imageLeftT0_ = imageLeftT1_;\n    imageRightT0_ = imageRightT1_;\n\n    if (currentVOFeatures.size() < 5) {\n      // There are not enough features to fully determine\n      // equations for pose estimation, so presume nothing and exit.\n      frame_id++;\n      return;\n    }\n\n    // ---------------------\n    // Triangulate 3D Points\n    // ---------------------\n    cv::Mat world_points_T0, world_homogenous_points_T0;\n    cv::triangulatePoints(leftCameraProjection_, rightCameraProjection_,\n                          pointsLeftT0, pointsRightT0, world_homogenous_points_T0);\n    cv::convertPointsFromHomogeneous(world_homogenous_points_T0.t(), world_points_T0);\n\n    // ---------------------\n    // Tracking transfomation\n    // ---------------------\n    cameraToWorld(leftCameraProjection_,\n        pointsLeftT1, world_points_T0, rotation, translation);\n\n    // ------------------------------------------------\n    // Integrating\n    // ------------------------------------------------\n    cv::Vec3f rotation_euler = rotationMatrixToEulerAngles(rotation);\n    // Don't perform an update if the output is unusually large, indicates a error elsewhere.\n    if (abs(rotation_euler[1]) < 0.1 && abs(rotation_euler[0]) < 0.1 &&\n        abs(rotation_euler[2]) < 0.1) {\n      integrateOdometryStereo(frame_id, frame_pose, rotation, translation);\n    }\n    cv::Mat xyz = frame_pose.col(3).clone();\n    cv::Mat R = frame_pose(cv::Rect(0, 0, 3, 3));\n\n    // publish\n    if (true) {\n        static tf::TransformBroadcaster br;\n\n        tf::Transform transform;\n        transform.setOrigin(tf::Vector3(xyz.at<double>(0), xyz.at<double>(1),\n                                        xyz.at<double>(2)));\n        tf::Quaternion q;\n        tf::Matrix3x3 R_tf(\n            R.at<double>(0, 0), R.at<double>(0, 1), R.at<double>(0, 2),\n            R.at<double>(1, 0), R.at<double>(1, 1), R.at<double>(1, 2),\n            R.at<double>(2, 0), R.at<double>(2, 1), R.at<double>(2, 2));\n        R_tf.getRotation(q);\n        transform.setRotation(q);\n        br.sendTransform(tf::StampedTransform(transform, ros::Time::now(),\n                                              \"odom\", \"camera\"));\n\n        transform.setOrigin(tf::Vector3(0.0, 0.0, 0.0));\n        tf::Quaternion q2(0.5, -0.5, 0.5, -0.5);\n        transform.setRotation(q2);\n        br.sendTransform(\n            tf::StampedTransform(transform, ros::Time::now(), \"map\",\n            \"odom\"));\n    }\n    frame_id++;\n  }\n\n  // --------------------------------\n  // https://github.com/hjamal3/stereo_visual_odometry/blob/main/src/feature.cpp\n  // --------------------------------\n\n  void deleteUnmatchFeaturesCircle(\n      std::vector<cv::Point2f> & points0, std::vector<cv::Point2f> & points1,\n      std::vector<cv::Point2f> & points2, std::vector<cv::Point2f> & points3,\n      std::vector<cv::Point2f> & points4, std::vector<int> & ages,\n      const std::vector<uchar> & status_all) {\n    // getting rid of points for which the KLT tracking failed or those who have\n    // gone outside the frame\n    int indexCorrection = 0;\n    for (int i = 0; i < status_all.size(); i++) {\n      cv::Point2f pt0 = points0.at(i - indexCorrection);\n      cv::Point2f pt1 = points1.at(i - indexCorrection);\n      cv::Point2f pt2 = points2.at(i - indexCorrection);\n      cv::Point2f pt3 = points3.at(i - indexCorrection);\n      cv::Point2f pt4 = points4.at(i - indexCorrection);\n      // TODO: Why are we even considering the x/y coordinates here, should we do it for pt4, and\n      // if we should consider it, should we consider the case where they are out of the image along the\n      // image size axes?\n      if ((status_all.at(i) == 0) || (pt3.x < 0) || (pt3.y < 0) ||\n           (pt2.x < 0) || (pt2.y < 0) ||\n           (pt1.x < 0) || (pt1.y < 0) ||\n           (pt0.x < 0) || (pt0.y < 0)) {\n        points0.erase(points0.begin() + (i - indexCorrection));\n        points1.erase(points1.begin() + (i - indexCorrection));\n        points2.erase(points2.begin() + (i - indexCorrection));\n        points3.erase(points3.begin() + (i - indexCorrection));\n        points4.erase(points4.begin() + (i - indexCorrection));\n\n        ages.erase(ages.begin() + (i - indexCorrection));\n        indexCorrection++;\n      }\n    }\n  }\n\n  void circularMatching(cv::Mat img_l_0, cv::Mat img_r_0, cv::Mat img_l_1,\n                        cv::Mat img_r_1, std::vector<cv::Point2f> & points_l_0,\n                        std::vector<cv::Point2f> & points_r_0,\n                        std::vector<cv::Point2f> & points_l_1,\n                        std::vector<cv::Point2f> & points_r_1,\n                        std::vector<cv::Point2f> & points_l_0_return,\n                        FeatureSet & current_features) {\n    std::vector<float> err;\n\n    cv::Size winSize =\n        cv::Size(20, 20); // Lucas-Kanade optical flow window size\n    cv::TermCriteria termcrit = cv::TermCriteria(\n        cv::TermCriteria::COUNT + cv::TermCriteria::EPS, 30, 0.01);\n\n    std::vector<uchar> status0;\n    std::vector<uchar> status1;\n    std::vector<uchar> status2;\n    std::vector<uchar> status3;\n\n    // Sparse iterative version of the Lucas-Kanade optical flow in pyramids.\n    calcOpticalFlowPyrLK(img_l_0, img_r_0, points_l_0, points_r_0, status0, err,\n                         winSize, 3, termcrit, 0, 0.001);\n    calcOpticalFlowPyrLK(img_r_0, img_r_1, points_r_0, points_r_1, status1, err,\n                         winSize, 3, termcrit, 0, 0.001);\n    calcOpticalFlowPyrLK(img_r_1, img_l_1, points_r_1, points_l_1, status2, err,\n                         winSize, 3, termcrit, 0, 0.001);\n    calcOpticalFlowPyrLK(img_l_1, img_l_0, points_l_1, points_l_0_return,\n                         status3, err, winSize, 3, termcrit, 0, 0.001);\n    if (status3.size() != status0.size() or points_l_0.size() != points_l_0_return.size()) {\n      cerr << \"Size of returned points was not correct!!\\n\";\n    }\n    std::vector<uchar> status_all;\n    for(int i = 0; i < status3.size(); i++) {\n      status_all[i] = status0[i] | status1[i] | status2[i] | status3[i];\n    }\n\n    deleteUnmatchFeaturesCircle(points_l_0, points_r_0, points_r_1, points_l_1,\n                                points_l_0_return, current_features.ages, status_all);\n    for (int i = 0; i < current_features.ages.size(); ++i) {\n      current_features.ages[i] += 1;\n    }\n  }\n\n\n  // --------------------------------\n  // https://github.com/hjamal3/stereo_visual_odometry/blob/main/src/utils.cpp\n  // --------------------------------\n\n  void integrateOdometryStereo(cv::Mat &frame_pose, const cv::Mat &rotation,\n                               const cv::Mat &translation_stereo) {\n    cv::Mat rigid_body_transformation;\n\n    cv::Mat addup = (cv::Mat_<double>(1, 4) << 0, 0, 0, 1);\n\n    cv::hconcat(rotation, translation_stereo, rigid_body_transformation);\n    cv::vconcat(rigid_body_transformation, addup, rigid_body_transformation);\n\n    const double scale = sqrt((translation_stereo.at<double>(0)) *\n                            (translation_stereo.at<double>(0)) +\n                        (translation_stereo.at<double>(1)) *\n                            (translation_stereo.at<double>(1)) +\n                        (translation_stereo.at<double>(2)) *\n                            (translation_stereo.at<double>(2)));\n\n    rigid_body_transformation = rigid_body_transformation.inv();\n    if (scale > 0.001 && scale < 10) // WHY DO WE NEED THIS\n    {\n      frame_pose = frame_pose * rigid_body_transformation;\n    } else {\n      std::cout << \"[WARNING] scale below 0.1, or incorrect translation\"\n                << std::endl;\n    }\n  }\n\n  // Calculates rotation matrix to euler angles\n  // The result is the same as MATLAB except the order\n  // of the euler angles ( x and z are swapped ).\n  cv::Vec3f const rotationMatrixToEulerAngles(cv::Mat & R) {\n    float sy = sqrt(R.at<double>(0, 0) * R.at<double>(0, 0) +\n                    R.at<double>(1, 0) * R.at<double>(1, 0));\n\n    bool singular = sy < 1e-6;\n\n    float x, y, z;\n    if (!singular) {\n      x = atan2(R.at<double>(2, 1), R.at<double>(2, 2));\n      y = atan2(-R.at<double>(2, 0), sy);\n      z = atan2(R.at<double>(1, 0), R.at<double>(0, 0));\n    } else {\n      x = atan2(-R.at<double>(1, 2), R.at<double>(1, 1));\n      y = atan2(-R.at<double>(2, 0), sy);\n      z = 0;\n    }\n    return cv::Vec3f(x, y, z);\n  }\n\n  // --------------------------------\n  // https://github.com/hjamal3/stereo_visual_odometry/blob/main/src/visualOdometry.cpp\n  // --------------------------------\n\n  std::vector<bool> findUnmovedPoints(const std::vector<cv::Point2f> & points_1,\n                       const std::vector<cv::Point2f> & points_2,\n                       const int threshold) {\n    std::vector<bool> status;\n    int offset;\n    for (int i = 0; i < points_1.size(); i++) {\n      offset = std::max(std::abs(points_1[i].x - points_2[i].x),\n                        std::abs(points_1[i].y - points_2[i].y));\n      if (offset > threshold) {\n        status.push_back(false);\n      } else {\n        status.push_back(true);\n      }\n    }\n    return status\n  }\n\n  void removeInvalidPoints(std::vector<cv::Point2f> & points,\n                           const std::vector<bool> &status) {\n    int index = 0;\n    for (int i = 0; i < status.size(); i++) {\n      if (status[i] == false) {\n        points.erase(points.begin() + index);\n      } else {\n        index++;\n      }\n    }\n  }\n  void cameraToWorld(\n      const cv::Mat & cameraProjection,\n      const std::vector<cv::Point2f> & cameraPoints, cv::Mat & worldPoints,\n      cv::Mat & rotation, cv::Mat & translation) {\n    // Calculate frame to frame transformation\n    cv::Mat distCoeffs = cv::Mat::zeros(4, 1, CV_64FC1);\n    cv::Mat rvec = cv::Mat::zeros(3, 1, CV_64FC1);\n    cv::Mat intrinsic_matrix =\n        (cv::Mat_<float>(3, 3) << cameraProjection.at<float>(0, 0),\n         cameraProjection.at<float>(0, 1),\n         cameraProjection.at<float>(0, 2),\n         cameraProjection.at<float>(1, 0),\n         cameraProjection.at<float>(1, 1),\n         cameraProjection.at<float>(1, 2),\n         cameraProjection.at<float>(1, 1),\n         cameraProjection.at<float>(1, 2),\n         cameraProjection.at<float>(1, 3));\n\n    int iterationsCount = 500; // number of Ransac iterations.\n    float reprojectionError = .5; // maximum allowed distance to consider it an inlier.\n    float confidence = 0.999; // RANSAC successful confidence.\n    bool useExtrinsicGuess = true;\n    int flags = cv::SOLVEPNP_ITERATIVE;\n\n    cv::Mat inliers;\n    cv::solvePnPRansac(worldPoints, cameraPoints, intrinsic_matrix, distCoeffs,\n                       rvec, translation, useExtrinsicGuess, iterationsCount,\n                       reprojectionError, confidence, inliers, flags);\n\n    cv::Rodrigues(rvec, rotation);\n  }\n\n  static void matchingFeatures(\n      const cv::Mat &imageLeft_t0, const cv::Mat &imageRight_t0,\n      const cv::Mat &imageLeft_t1, const cv::Mat &imageRight_t1,\n      FeatureSet &currentVOFeatures, std::vector<cv::Point2f> &pointsLeftT0,\n      std::vector<cv::Point2f> &pointsRightT0,\n      std::vector<cv::Point2f> &pointsLeftT1,\n      std::vector<cv::Point2f> &pointsRightT1) {\n    \n    std::vector<cv::Point2f> pointsLeftReturn_t0; // feature points to check\n                                                  // circular matching validation\n    // Append new features with old features.\n    currentVOFeatures.appendFeaturesFromImage(imageLeft_t0);\n\n    // --------------------------------------------------------\n    // Feature tracking using KLT tracker, bucketing and circular matching.\n    // --------------------------------------------------------\n    int bucket_size =\n        std::min(imageLeft_t0.rows, imageLeft_t0.cols) / BUCKETS_PER_AXIS;\n    int features_per_bucket = FEATURES_PER_BUCKET;\n\n    // Filter features in currentVOFeatures to leave just one per bucket.\n    currentVOFeatures.filterByBucketLocation(imageLeft_t0, bucket_size,\n                      features_per_bucket);\n\n    pointsLeftT0 = currentVOFeatures.points;\n\n    circularMatching(imageLeft_t0, imageRight_t0, imageLeft_t1, imageRight_t1,\n                     pointsLeftT0, pointsRightT0, pointsLeftT1, pointsRightT1,\n                     pointsLeftReturn_t0, currentVOFeatures);\n\n    // Check if circled back points are in range of original points.\n    std::vector<bool> status = findUnmovedPoints(pointsLeftT0, pointsLeftReturn_t0, status, 0);\n    removeInvalidPoints(pointsLeftT0, status);\n    removeInvalidPoints(pointsLeftT1, status);\n    removeInvalidPoints(pointsRightT0, status);\n    removeInvalidPoints(pointsRightT1, status);\n\n    // Update current tracked points.\n    currentVOFeatures.points = pointsLeftT1;\n  }\n} // namespace visual_odometry\n"
        }
    ]
}