{
    "sourceFile": "src/utils.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1648602927835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1648602927835,
            "name": "Commit-0",
            "content": "#include \"utils.h\"\n\n// --------------------------------\n// Visualization\n// --------------------------------\nvoid drawFeaturePoints(cv::Mat image, std::vector<cv::Point2f>& points)\n{\n    int radius = 2;\n    \n    for (int i = 0; i < points.size(); i++)\n    {\n        circle(image, cv::Point(points[i].x, points[i].y), radius, CV_RGB(255,255,255));\n    }\n}\n\nvoid display(int frame_id, cv::Mat& trajectory, cv::Mat& pose, std::vector<Matrix>& pose_matrix_gt, float fps, bool show_gt)\n{\n    // draw estimated trajectory \n    int x = int(pose.at<double>(0)) + 300;\n    int y = int(pose.at<double>(2)) + 100;\n    circle(trajectory, cv::Point(x, y) ,1, CV_RGB(255,0,0), 2);\n\n    if (show_gt)\n    {\n      // draw ground truth trajectory \n      cv::Mat pose_gt = cv::Mat::zeros(1, 3, CV_64F);\n      \n      pose_gt.at<double>(0) = pose_matrix_gt[frame_id].val[0][3];\n      pose_gt.at<double>(1) = pose_matrix_gt[frame_id].val[0][7];\n      pose_gt.at<double>(2) = pose_matrix_gt[frame_id].val[0][11];\n      x = int(pose_gt.at<double>(0)) + 300;\n      y = int(pose_gt.at<double>(2)) + 100;\n      circle(trajectory, cv::Point(x, y) ,1, CV_RGB(255,255,0), 2);\n    }\n    // print info\n\n    // rectangle( traj, Point(10, 30), Point(550, 50), CV_RGB(0,0,0), CV_FILLED);\n    // sprintf(text, \"FPS: %02f\", fps);\n    // putText(traj, text, textOrg, fontFace, fontScale, Scalar::all(255), thickness, 8);\n\n    cv::imshow( \"Trajectory\", trajectory );\n    cv::waitKey(1);\n}\n\n\n\n// --------------------------------\n// Transformation\n// --------------------------------\n\n// void cv_rotm_to_eigen_quat(Eigen::Quaternion<double> & q, const cv::Mat & R)\n// {\n//     static Eigen::Matrix<double,3,3> R_eig(3,3);\n//     static Eigen::Matrix<double,3,3> R_eig_T(3,3);\n//     R_eig << R.at<double>(0,0), R.at<double>(0,1), R.at<double>(0,2), R.at<double>(1,0), R.at<double>(1,1),\n//     R.at<double>(1,2), R.at<double>(2,0), R.at<double>(2,1),R.at<double>(2,2);\n//     R_eig_T = R_eig.transpose();\n//     q = R_eig_T;\n\n// }\n\n\nvoid integrateOdometryStereo(int frame_i, cv::Mat& frame_pose, const cv::Mat& rotation, const cv::Mat& translation_stereo)\n{\n\n    // std::cout << \"rotation\" << rotation << std::endl;\n    std::cout << \"translation_stereo\" << translation_stereo << std::endl;\n\n    cv::Mat rigid_body_transformation;\n\n    cv::Mat addup = (cv::Mat_<double>(1, 4) << 0, 0, 0, 1);\n\n    cv::hconcat(rotation, translation_stereo, rigid_body_transformation);\n    cv::vconcat(rigid_body_transformation, addup, rigid_body_transformation);\n\n    // std::cout << \"rigid_body_transformation\" << rigid_body_transformation << std::endl;\n\n    double scale = sqrt((translation_stereo.at<double>(0))*(translation_stereo.at<double>(0)) \n                        + (translation_stereo.at<double>(1))*(translation_stereo.at<double>(1))\n                        + (translation_stereo.at<double>(2))*(translation_stereo.at<double>(2))) ;\n\n    // frame_pose = frame_pose * rigid_body_transformation;\n    std::cout << \"scale: \" << scale << std::endl;\n\n    rigid_body_transformation = rigid_body_transformation.inv();\n    // if ((scale>0.1)&&(translation_stereo.at<double>(2) > translation_stereo.at<double>(0)) && (translation_stereo.at<double>(2) > translation_stereo.at<double>(1))) \n    ///if (scale > 0.05 && scale < 10) \n    if (scale > 0.001 && scale < 10) // WHY DO WE NEED THIS\n    {\n      // std::cout << \"Rpose\" << Rpose << std::endl;\n\n      frame_pose = frame_pose * rigid_body_transformation;\n\n    }\n    else \n    {\n     std::cout << \"[WARNING] scale below 0.1, or incorrect translation\" << std::endl;\n    }\n}\n\nbool isRotationMatrix(cv::Mat &R)\n{\n    cv::Mat Rt;\n    transpose(R, Rt);\n    cv::Mat shouldBeIdentity = Rt * R;\n    cv::Mat I = cv::Mat::eye(3,3, shouldBeIdentity.type());\n     \n    return  norm(I, shouldBeIdentity) < 1e-6;\n}\n \n// Calculates rotation matrix to euler angles\n// The result is the same as MATLAB except the order\n// of the euler angles ( x and z are swapped ).\ncv::Vec3f rotationMatrixToEulerAngles(cv::Mat &R)\n{\n \n    assert(isRotationMatrix(R));\n     \n    float sy = sqrt(R.at<double>(0,0) * R.at<double>(0,0) +  R.at<double>(1,0) * R.at<double>(1,0) );\n \n    bool singular = sy < 1e-6; // If\n \n    float x, y, z;\n    if (!singular)\n    {\n        x = atan2(R.at<double>(2,1) , R.at<double>(2,2));\n        y = atan2(-R.at<double>(2,0), sy);\n        z = atan2(R.at<double>(1,0), R.at<double>(0,0));\n    }\n    else\n    {\n        x = atan2(-R.at<double>(1,2), R.at<double>(1,1));\n        y = atan2(-R.at<double>(2,0), sy);\n        z = 0;\n    }\n    return cv::Vec3f(x, y, z);\n     \n}\n\n// --------------------------------\n// I/O\n// --------------------------------\n\nvoid loadImageLeft(cv::Mat& image_color, cv::Mat& image_gary, int frame_id, std::string filepath){\n    char file[200];\n    sprintf(file, \"image_0/%06d.png\", frame_id);\n    std::string filename = filepath + std::string(file);\n    image_color = cv::imread(filename, cv::IMREAD_COLOR);\n    cvtColor(image_color, image_gary, cv::COLOR_BGR2GRAY);\n}\n\nvoid loadImageRight(cv::Mat& image_color, cv::Mat& image_gary, int frame_id, std::string filepath){\n    char file[200];\n    sprintf(file, \"image_1/%06d.png\", frame_id);\n    std::string filename = filepath + std::string(file);\n    image_color = cv::imread(filename, cv::IMREAD_COLOR);\n    cvtColor(image_color, image_gary, cv::COLOR_BGR2GRAY);\n}\n\n\n\n\n\n\n\n\n\n\n\n"
        }
    ]
}