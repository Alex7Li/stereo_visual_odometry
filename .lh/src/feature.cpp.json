{
    "sourceFile": "src/feature.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 35,
            "patches": [
                {
                    "date": 1648603748883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1648603851054,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,13 +55,12 @@\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKET_DIVISOR; // TODO PARAM\n \n     // filter features in currentVOFeatures so that one per bucket\n     bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n-    debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n+    // debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n \n     /* Display feature points after bucketing */\n     // displayPoints(image,current_features.points);\n-\n }\n \n void bucketingFeatures(const cv::Mat& image, FeatureSet& current_features, int bucket_size, int features_per_bucket)\n {\n"
                },
                {
                    "date": 1648669653705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,8 +52,9 @@\n     // displayPoints(image,current_features.points);\n \n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKET_DIVISOR; // TODO PARAM\n+    dbg(current_features.points.size());\n \n     // filter features in currentVOFeatures so that one per bucket\n     bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n     // debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n"
                },
                {
                    "date": 1648670328122,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n #include \"feature.h\"\n #include \"bucket.h\"\n-\n+#include \"vo.h\"\n #if USE_CUDA\n static void download(const cv::cuda::GpuMat& d_mat, std::vector<cv::Point2f>& vec)\n {\n     vec.resize(d_mat.cols);\n@@ -52,8 +52,9 @@\n     // displayPoints(image,current_features.points);\n \n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKET_DIVISOR; // TODO PARAM\n+    dbg(bucket_size);\n     dbg(current_features.points.size());\n \n     // filter features in currentVOFeatures so that one per bucket\n     bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n"
                },
                {
                    "date": 1648670857757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,18 +71,18 @@\n     // bucket_size: bucket size in pixel is bucket_size*bucket_size\n     // features_per_bucket: number of selected features per bucket\n     int image_height = image.rows;\n     int image_width = image.cols;\n-    int buckets_nums_height = image_height/bucket_size;\n-    int buckets_nums_width = image_width/bucket_size;\n+    int buckets_nums_height = image_height/bucket_size + 1;\n+    int buckets_nums_width = image_width/bucket_size + 1;\n     int buckets_number = buckets_nums_height * buckets_nums_width;\n \n     std::vector<Bucket> Buckets;\n \n     // initialize all the buckets\n-    for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_nums_height; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < buckets_nums_width; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n             if (buckets_idx_height > BUCKET_START_ROW) Buckets.push_back(Bucket(features_per_bucket));\n             else Buckets.push_back(Bucket(0));\n@@ -100,11 +100,11 @@\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n     current_features.clear();\n-    for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_nums_height; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < buckets_nums_width; buckets_idx_width++)\n         {\n             buckets_idx = buckets_idx_height*buckets_nums_width + buckets_idx_width;\n             FeatureSet bucket_features = Buckets[buckets_idx].features;\n             current_features.points.insert(current_features.points.end(), bucket_features.points.begin(), bucket_features.points.end());\n"
                },
                {
                    "date": 1648670882072,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,9 +73,11 @@\n     int image_height = image.rows;\n     int image_width = image.cols;\n     int buckets_nums_height = image_height/bucket_size + 1;\n     int buckets_nums_width = image_width/bucket_size + 1;\n-    int buckets_number = buckets_nums_height * buckets_nums_width;\n+    dbg(buckets_nums_height);\n+    dbg(buckets_nums_width);\n+    \n \n     std::vector<Bucket> Buckets;\n \n     // initialize all the buckets\n"
                },
                {
                    "date": 1648671118479,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,10 +52,8 @@\n     // displayPoints(image,current_features.points);\n \n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKET_DIVISOR; // TODO PARAM\n-    dbg(bucket_size);\n-    dbg(current_features.points.size());\n \n     // filter features in currentVOFeatures so that one per bucket\n     bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n     // debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n@@ -75,8 +73,9 @@\n     int buckets_nums_height = image_height/bucket_size + 1;\n     int buckets_nums_width = image_width/bucket_size + 1;\n     dbg(buckets_nums_height);\n     dbg(buckets_nums_width);\n+    dbg(bucket_size);\n     \n \n     std::vector<Bucket> Buckets;\n \n"
                },
                {
                    "date": 1648671244654,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n     /* Display feature points after feature detection */\n     // displayPoints(image,current_features.points);\n \n     /* Bucketing features */\n-    const int bucket_size = std::min(image.rows,image.cols)/BUCKET_DIVISOR; // TODO PARAM\n+    const int bucket_size = 1 + std::min(image.rows,image.cols)/BUCKET_DIVISOR; // TODO PARAM\n \n     // filter features in currentVOFeatures so that one per bucket\n     bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n     // debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n@@ -71,11 +71,8 @@\n     int image_height = image.rows;\n     int image_width = image.cols;\n     int buckets_nums_height = image_height/bucket_size + 1;\n     int buckets_nums_width = image_width/bucket_size + 1;\n-    dbg(buckets_nums_height);\n-    dbg(buckets_nums_width);\n-    dbg(bucket_size);\n     \n \n     std::vector<Bucket> Buckets;\n \n"
                },
                {
                    "date": 1648671486612,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,10 @@\n     int image_height = image.rows;\n     int image_width = image.cols;\n     int buckets_nums_height = image_height/bucket_size + 1;\n     int buckets_nums_width = image_width/bucket_size + 1;\n-    \n+    dbg(image_height);\n+    dbg(image_width);\n \n     std::vector<Bucket> Buckets;\n \n     // initialize all the buckets\n"
                },
                {
                    "date": 1648671501776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,10 +71,11 @@\n     int image_height = image.rows;\n     int image_width = image.cols;\n     int buckets_nums_height = image_height/bucket_size + 1;\n     int buckets_nums_width = image_width/bucket_size + 1;\n-    dbg(image_height);\n-    dbg(image_width);\n+    dbg(buckets_nums_height);\n+    dbg(buckets_nums_height);\n+    dbg(buckets_size);\n \n     std::vector<Bucket> Buckets;\n \n     // initialize all the buckets\n"
                },
                {
                    "date": 1648671589685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,10 +72,10 @@\n     int image_width = image.cols;\n     int buckets_nums_height = image_height/bucket_size + 1;\n     int buckets_nums_width = image_width/bucket_size + 1;\n     dbg(buckets_nums_height);\n-    dbg(buckets_nums_height);\n-    dbg(buckets_size);\n+    dbg(buckets_nums_width);\n+    dbg(bucket_size);\n \n     std::vector<Bucket> Buckets;\n \n     // initialize all the buckets\n"
                },
                {
                    "date": 1648671762974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,8 +95,10 @@\n     {\n         buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n+        dbg(i);\n+        dbg(buckets_idx);\n         Buckets[buckets_idx].add_feature(current_features.points[i], current_features.ages[i], current_features.strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648671881512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,8 +92,10 @@\n     /* Put all current features into buckets by their location and scores */\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n     for (int i = 0; i < current_features.points.size(); ++i)\n     {\n+        dbg(current_features.points[i].y);\n+        dbg(current_features.points[i].x);\n         buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n         dbg(i);\n"
                },
                {
                    "date": 1648672093764,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,8 +42,10 @@\n     std::vector<cv::Point2f>  points_new;\n     std::vector<float>  response_strength;\n \n     featureDetectionFast(image, points_new, response_strength);\n+    dbg(points_new[i].y)\n+    dbg(points_new[i].x)\n     current_features.points.insert(current_features.points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     current_features.ages.insert(current_features.ages.end(), ages_new.begin(), ages_new.end());\n     current_features.strengths.insert(current_features.strengths.end(), response_strength.begin(), response_strength.end());\n"
                },
                {
                    "date": 1648672104691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,10 +42,10 @@\n     std::vector<cv::Point2f>  points_new;\n     std::vector<float>  response_strength;\n \n     featureDetectionFast(image, points_new, response_strength);\n-    dbg(points_new[i].y)\n-    dbg(points_new[i].x)\n+    dbg(points_new[0].y)\n+    dbg(points_new[0].x)\n     current_features.points.insert(current_features.points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     current_features.ages.insert(current_features.ages.end(), ages_new.begin(), ages_new.end());\n     current_features.strengths.insert(current_features.strengths.end(), response_strength.begin(), response_strength.end());\n"
                },
                {
                    "date": 1648672119905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,15 +94,13 @@\n     /* Put all current features into buckets by their location and scores */\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n     for (int i = 0; i < current_features.points.size(); ++i)\n     {\n-        dbg(current_features.points[i].y);\n-        dbg(current_features.points[i].x);\n+        // dbg(current_features.points[i].y);\n+        // dbg(current_features.points[i].x);\n         buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n-        dbg(i);\n-        dbg(buckets_idx);\n         Buckets[buckets_idx].add_feature(current_features.points[i], current_features.ages[i], current_features.strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648672129658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,8 +99,10 @@\n         // dbg(current_features.points[i].x);\n         buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n+        // dbg(i);\n+        // dbg(buckets_idx);\n         Buckets[buckets_idx].add_feature(current_features.points[i], current_features.ages[i], current_features.strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648672163549,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,10 +42,10 @@\n     std::vector<cv::Point2f>  points_new;\n     std::vector<float>  response_strength;\n \n     featureDetectionFast(image, points_new, response_strength);\n+    dbg(points_new[0].x)\n     dbg(points_new[0].y)\n-    dbg(points_new[0].x)\n     current_features.points.insert(current_features.points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     current_features.ages.insert(current_features.ages.end(), ages_new.begin(), ages_new.end());\n     current_features.strengths.insert(current_features.strengths.end(), response_strength.begin(), response_strength.end());\n"
                },
                {
                    "date": 1648672174816,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,11 +42,11 @@\n     std::vector<cv::Point2f>  points_new;\n     std::vector<float>  response_strength;\n \n     featureDetectionFast(image, points_new, response_strength);\n-    dbg(points_new[0].x)\n-    dbg(points_new[0].y)\n     current_features.points.insert(current_features.points.end(), points_new.begin(), points_new.end());\n+    dbg(current_features.points[0].x)\n+    dbg(current_features.points[0].y)\n     std::vector<int>  ages_new(points_new.size(), 0);\n     current_features.ages.insert(current_features.ages.end(), ages_new.begin(), ages_new.end());\n     current_features.strengths.insert(current_features.strengths.end(), response_strength.begin(), response_strength.end());\n \n"
                },
                {
                    "date": 1648672197376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,10 +43,8 @@\n     std::vector<float>  response_strength;\n \n     featureDetectionFast(image, points_new, response_strength);\n     current_features.points.insert(current_features.points.end(), points_new.begin(), points_new.end());\n-    dbg(current_features.points[0].x)\n-    dbg(current_features.points[0].y)\n     std::vector<int>  ages_new(points_new.size(), 0);\n     current_features.ages.insert(current_features.ages.end(), ages_new.begin(), ages_new.end());\n     current_features.strengths.insert(current_features.strengths.end(), response_strength.begin(), response_strength.end());\n \n@@ -56,8 +54,11 @@\n     /* Bucketing features */\n     const int bucket_size = 1 + std::min(image.rows,image.cols)/BUCKET_DIVISOR; // TODO PARAM\n \n     // filter features in currentVOFeatures so that one per bucket\n+    dbg(current_features.points[0].x)\n+    dbg(current_features.points[0].y)\n+    dbg(current_features.points.size())\n     bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n     // debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n \n     /* Display feature points after bucketing */\n"
                },
                {
                    "date": 1648672249763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,11 +54,8 @@\n     /* Bucketing features */\n     const int bucket_size = 1 + std::min(image.rows,image.cols)/BUCKET_DIVISOR; // TODO PARAM\n \n     // filter features in currentVOFeatures so that one per bucket\n-    dbg(current_features.points[0].x)\n-    dbg(current_features.points[0].y)\n-    dbg(current_features.points.size())\n     bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n     // debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n \n     /* Display feature points after bucketing */\n"
                },
                {
                    "date": 1648672260685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,12 +90,12 @@\n     }\n \n     /* Put all current features into buckets by their location and scores */\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n+    dbg(current_features.points[0].y);\n+    dbg(current_features.points[0].x);\n     for (int i = 0; i < current_features.points.size(); ++i)\n     {\n-        // dbg(current_features.points[i].y);\n-        // dbg(current_features.points[i].x);\n         buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n         // dbg(i);\n"
                },
                {
                    "date": 1648672272088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,10 +97,10 @@\n     {\n         buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n-        // dbg(i);\n-        // dbg(buckets_idx);\n+        dbg(i);\n+        dbg(buckets_idx);\n         Buckets[buckets_idx].add_feature(current_features.points[i], current_features.ages[i], current_features.strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648672579990,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,17 +90,13 @@\n     }\n \n     /* Put all current features into buckets by their location and scores */\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n-    dbg(current_features.points[0].y);\n-    dbg(current_features.points[0].x);\n     for (int i = 0; i < current_features.points.size(); ++i)\n     {\n         buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n-        dbg(i);\n-        dbg(buckets_idx);\n         Buckets[buckets_idx].add_feature(current_features.points[i], current_features.ages[i], current_features.strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648672642891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,8 +56,9 @@\n \n     // filter features in currentVOFeatures so that one per bucket\n     bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n     // debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n+    dbg(bucket_size);\n \n     /* Display feature points after bucketing */\n     // displayPoints(image,current_features.points);\n }\n"
                },
                {
                    "date": 1648672661024,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n \n     // filter features in currentVOFeatures so that one per bucket\n     bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n     // debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n-    dbg(bucket_size);\n+    dbg(current_features.points.size());\n \n     /* Display feature points after bucketing */\n     // displayPoints(image,current_features.points);\n }\n"
                },
                {
                    "date": 1648672757233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,8 +107,9 @@\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_nums_width; buckets_idx_width++)\n         {\n             buckets_idx = buckets_idx_height*buckets_nums_width + buckets_idx_width;\n             FeatureSet bucket_features = Buckets[buckets_idx].features;\n+            dbg(buckets[buckets_idx].features().size());\n             current_features.points.insert(current_features.points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             current_features.ages.insert(current_features.ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             current_features.strengths.insert(current_features.strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n         }\n"
                },
                {
                    "date": 1648672767139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,9 +107,9 @@\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_nums_width; buckets_idx_width++)\n         {\n             buckets_idx = buckets_idx_height*buckets_nums_width + buckets_idx_width;\n             FeatureSet bucket_features = Buckets[buckets_idx].features;\n-            dbg(buckets[buckets_idx].features().size());\n+            dbg(Buckets[buckets_idx].features().size());\n             current_features.points.insert(current_features.points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             current_features.ages.insert(current_features.ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             current_features.strengths.insert(current_features.strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n         }\n"
                },
                {
                    "date": 1648672790720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,9 +107,10 @@\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_nums_width; buckets_idx_width++)\n         {\n             buckets_idx = buckets_idx_height*buckets_nums_width + buckets_idx_width;\n             FeatureSet bucket_features = Buckets[buckets_idx].features;\n-            dbg(Buckets[buckets_idx].features().size());\n+            dbg(buckets_idx);\n+            dbg(Buckets[buckets_idx].feature).size());\n             current_features.points.insert(current_features.points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             current_features.ages.insert(current_features.ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             current_features.strengths.insert(current_features.strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n         }\n"
                },
                {
                    "date": 1648672898789,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,8 +96,14 @@\n     {\n         buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n+      if(buckets_idx == 57){\n+          dbg(i);\n+          dbg(points[i]);\n+          dbg(ages[i]);\n+          dbg(strengths[i]);\n+        }\n         Buckets[buckets_idx].add_feature(current_features.points[i], current_features.ages[i], current_features.strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n@@ -108,9 +114,9 @@\n         {\n             buckets_idx = buckets_idx_height*buckets_nums_width + buckets_idx_width;\n             FeatureSet bucket_features = Buckets[buckets_idx].features;\n             dbg(buckets_idx);\n-            dbg(Buckets[buckets_idx].feature).size());\n+            dbg(Buckets[buckets_idx].features.size());\n             current_features.points.insert(current_features.points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             current_features.ages.insert(current_features.ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             current_features.strengths.insert(current_features.strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n         }\n"
                },
                {
                    "date": 1648672918728,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,11 +98,11 @@\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n       if(buckets_idx == 57){\n           dbg(i);\n-          dbg(points[i]);\n-          dbg(ages[i]);\n-          dbg(strengths[i]);\n+          dbg(current_features.points[i]);\n+          dbg(current_features.ages[i]);\n+          dbg(current_features.strengths[i]);\n         }\n         Buckets[buckets_idx].add_feature(current_features.points[i], current_features.ages[i], current_features.strengths[i]);\n     }\n \n"
                },
                {
                    "date": 1648672987182,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,15 +96,18 @@\n     {\n         buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n-      if(buckets_idx == 57){\n+        if(buckets_idx == 57){\n           dbg(i);\n           dbg(current_features.points[i]);\n           dbg(current_features.ages[i]);\n           dbg(current_features.strengths[i]);\n         }\n         Buckets[buckets_idx].add_feature(current_features.points[i], current_features.ages[i], current_features.strengths[i]);\n+        if(buckets_idx == 57){\n+          dbg(Buckets[buckets_idx].size())\n+        }\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n     current_features.clear();\n"
                },
                {
                    "date": 1648673149716,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,9 @@\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_nums_width; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n-            if (buckets_idx_height > BUCKET_START_ROW) Buckets.push_back(Bucket(features_per_bucket));\n+            if (buckets_idx_height >= BUCKET_START_ROW) Buckets.push_back(Bucket(features_per_bucket));\n             else Buckets.push_back(Bucket(0));\n         }\n     }\n \n"
                },
                {
                    "date": 1648673163672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,9 @@\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_nums_width; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n-            if (buckets_idx_height >= BUCKET_START_ROW) Buckets.push_back(Bucket(features_per_bucket));\n+            if (buckets_idx_height > BUCKET_START_ROW) Buckets.push_back(Bucket(features_per_bucket));\n             else Buckets.push_back(Bucket(0));\n         }\n     }\n \n"
                },
                {
                    "date": 1648673199775,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,8 @@\n \n     // filter features in currentVOFeatures so that one per bucket\n     bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n     // debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n-    dbg(current_features.points.size());\n \n     /* Display feature points after bucketing */\n     // displayPoints(image,current_features.points);\n }\n@@ -96,18 +95,9 @@\n     {\n         buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n         buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n-        if(buckets_idx == 57){\n-          dbg(i);\n-          dbg(current_features.points[i]);\n-          dbg(current_features.ages[i]);\n-          dbg(current_features.strengths[i]);\n-        }\n         Buckets[buckets_idx].add_feature(current_features.points[i], current_features.ages[i], current_features.strengths[i]);\n-        if(buckets_idx == 57){\n-          dbg(Buckets[buckets_idx].size())\n-        }\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n     current_features.clear();\n@@ -116,10 +106,8 @@\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_nums_width; buckets_idx_width++)\n         {\n             buckets_idx = buckets_idx_height*buckets_nums_width + buckets_idx_width;\n             FeatureSet bucket_features = Buckets[buckets_idx].features;\n-            dbg(buckets_idx);\n-            dbg(Buckets[buckets_idx].features.size());\n             current_features.points.insert(current_features.points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             current_features.ages.insert(current_features.ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             current_features.strengths.insert(current_features.strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n         }\n"
                },
                {
                    "date": 1648673216876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,11 +71,8 @@\n     int image_height = image.rows;\n     int image_width = image.cols;\n     int buckets_nums_height = image_height/bucket_size + 1;\n     int buckets_nums_width = image_width/bucket_size + 1;\n-    dbg(buckets_nums_height);\n-    dbg(buckets_nums_width);\n-    dbg(bucket_size);\n \n     std::vector<Bucket> Buckets;\n \n     // initialize all the buckets\n"
                }
            ],
            "date": 1648603748883,
            "name": "Commit-0",
            "content": "#include \"feature.h\"\n#include \"bucket.h\"\n\n#if USE_CUDA\nstatic void download(const cv::cuda::GpuMat& d_mat, std::vector<cv::Point2f>& vec)\n{\n    vec.resize(d_mat.cols);\n    cv::Mat mat(1, d_mat.cols, CV_32FC2, (void*)&vec[0]);\n    d_mat.download(mat);\n}\n\nstatic void download(const cv::cuda::GpuMat& d_mat, std::vector<uchar>& vec)\n{\n    vec.resize(d_mat.cols);\n    cv::Mat mat(1, d_mat.cols, CV_8UC1, (void*)&vec[0]);\n    d_mat.download(mat);\n}\n#endif\n\n\nvoid featureDetectionFast(cv::Mat image, std::vector<cv::Point2f>& points, std::vector<float> & response_strength)  \n{   \n    //uses FAST as for feature dection, modify parameters as necessary\n\n    std::vector<cv::KeyPoint> keypoints;\n    bool nonmaxSuppression = true;\n    cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n    \n    // other feature detectors    \n    // static cv::Ptr<cv::Feature2D> f2d = cv::xfeatures2d::StarDetector::create();\n    // f2d->detect(image, keypoints);\n\n    cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n    response_strength.reserve(points.size());\n    for (const auto keypoint : keypoints) response_strength.push_back(keypoint.response); \n}\n\n/* Add more features to feature set using image */\nvoid appendNewFeatures(const cv::Mat& image, FeatureSet& current_features)\n{\n    /* Fast feature detection */\n    std::vector<cv::Point2f>  points_new;\n    std::vector<float>  response_strength;\n\n    featureDetectionFast(image, points_new, response_strength);\n    current_features.points.insert(current_features.points.end(), points_new.begin(), points_new.end());\n    std::vector<int>  ages_new(points_new.size(), 0);\n    current_features.ages.insert(current_features.ages.end(), ages_new.begin(), ages_new.end());\n    current_features.strengths.insert(current_features.strengths.end(), response_strength.begin(), response_strength.end());\n\n    /* Display feature points after feature detection */\n    // displayPoints(image,current_features.points);\n\n    /* Bucketing features */\n    const int bucket_size = std::min(image.rows,image.cols)/BUCKET_DIVISOR; // TODO PARAM\n\n    // filter features in currentVOFeatures so that one per bucket\n    bucketingFeatures(image, current_features, bucket_size, FEATURES_PER_BUCKET);\n    debug(\"[feature]: number of features after bucketing: \" + std::to_string(current_features.points.size()));\n\n    /* Display feature points after bucketing */\n    // displayPoints(image,current_features.points);\n\n}\n\nvoid bucketingFeatures(const cv::Mat& image, FeatureSet& current_features, int bucket_size, int features_per_bucket)\n{\n    // This function buckets features\n    // image: only use for getting dimension of the image\n    // bucket_size: bucket size in pixel is bucket_size*bucket_size\n    // features_per_bucket: number of selected features per bucket\n    int image_height = image.rows;\n    int image_width = image.cols;\n    int buckets_nums_height = image_height/bucket_size;\n    int buckets_nums_width = image_width/bucket_size;\n    int buckets_number = buckets_nums_height * buckets_nums_width;\n\n    std::vector<Bucket> Buckets;\n\n    // initialize all the buckets\n    for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height; buckets_idx_height++)\n    {\n        for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width; buckets_idx_width++)\n        {\n            // Ignore top rows of image.\n            if (buckets_idx_height > BUCKET_START_ROW) Buckets.push_back(Bucket(features_per_bucket));\n            else Buckets.push_back(Bucket(0));\n        }\n    }\n\n    /* Put all current features into buckets by their location and scores */\n    int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n    for (int i = 0; i < current_features.points.size(); ++i)\n    {\n        buckets_nums_height_idx = current_features.points[i].y/bucket_size;\n        buckets_nums_width_idx = current_features.points[i].x/bucket_size;\n        buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n        Buckets[buckets_idx].add_feature(current_features.points[i], current_features.ages[i], current_features.strengths[i]);\n    }\n\n    /* Take features from buckets and put them back into the feature set */\n    current_features.clear();\n    for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height; buckets_idx_height++)\n    {\n        for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width; buckets_idx_width++)\n        {\n            buckets_idx = buckets_idx_height*buckets_nums_width + buckets_idx_width;\n            FeatureSet bucket_features = Buckets[buckets_idx].features;\n            current_features.points.insert(current_features.points.end(), bucket_features.points.begin(), bucket_features.points.end());\n            current_features.ages.insert(current_features.ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n            current_features.strengths.insert(current_features.strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n        }\n    }\n}\n\n/* Delete any points that optical flow failed for. */\nvoid deleteUnmatchFeaturesCircle(std::vector<cv::Point2f>& points0, std::vector<cv::Point2f>& points1,\n                          std::vector<cv::Point2f>& points2, std::vector<cv::Point2f>& points3,\n                          std::vector<cv::Point2f>& points0_return,\n                          std::vector<uchar>& status0, std::vector<uchar>& status1,\n                          std::vector<uchar>& status2, std::vector<uchar>& status3,\n                          FeatureSet & current_features)\n    {\n\n    //getting rid of points for which the KLT tracking failed or those who have gone outside the frame\n    for (int i = 0; i < current_features.ages.size(); ++i)\n    {\n        current_features.ages[i] += 1;\n    }\n\n    int indexCorrection = 0;\n    for( int i=0; i<status3.size(); i++)\n    {  \n        cv::Point2f pt0 = points0.at(i- indexCorrection);\n        cv::Point2f pt1 = points1.at(i- indexCorrection);\n        cv::Point2f pt2 = points2.at(i- indexCorrection);\n        cv::Point2f pt3 = points3.at(i- indexCorrection);\n        cv::Point2f pt0_r = points0_return.at(i- indexCorrection);\n\n        if ((status3.at(i) == 0) || (pt3.x<0) || (pt3.y<0) ||\n            (status2.at(i) == 0) || (pt2.x<0) || (pt2.y<0) ||\n            (status1.at(i) == 0) || (pt1.x<0) || (pt1.y<0) ||\n            (status0.at(i) == 0) || (pt0.x<0) || (pt0.y<0))   \n        {\n            if((pt0.x<0) || (pt0.y<0) || (pt1.x<0) || (pt1.y<0) \n                || (pt2.x<0) || (pt2.y<0) || (pt3.x<0) || (pt3.y<0))    \n            {\n                status3.at(i) = 0;\n            }\n            points0.erase (points0.begin() + (i - indexCorrection));\n            points1.erase (points1.begin() + (i - indexCorrection));\n            points2.erase (points2.begin() + (i - indexCorrection));\n            points3.erase (points3.begin() + (i - indexCorrection));\n            points0_return.erase (points0_return.begin() + (i - indexCorrection));\n\n            // also update the feature set \n            current_features.ages.erase (current_features.ages.begin() + (i - indexCorrection));\n            current_features.strengths.erase (current_features.strengths.begin() + (i - indexCorrection));\n\n            indexCorrection++;\n        }\n\n    }  \n}\n\n\nvoid featureDetectionGoodFeaturesToTrack(cv::Mat image, std::vector<cv::Point2f>& points)  \n{   \n    //uses GoodFeaturesToTrack for feature dection, modify parameters as necessary\n\n    int maxCorners = 5000;\n    double qualityLevel = 0.01;\n    double minDistance = 5.;\n    int blockSize = 3;\n    bool useHarrisDetector = false;\n    double k = 0.04;\n    cv::Mat mask;\n\n    cv::goodFeaturesToTrack( image, points, maxCorners, qualityLevel, minDistance, mask, blockSize, useHarrisDetector, k );\n}\n\n\n//this function automatically gets rid of points for which tracking fails   \nvoid circularMatching(cv::Mat img_l_0, cv::Mat img_r_0, cv::Mat img_l_1, cv::Mat img_r_1,\n                      std::vector<cv::Point2f>& points_l_0, std::vector<cv::Point2f>& points_r_0,\n                      std::vector<cv::Point2f>& points_l_1, std::vector<cv::Point2f>& points_r_1,\n                      std::vector<cv::Point2f>& points_l_0_return,\n                      FeatureSet& current_features) { \n      std::vector<float> err;         \n\n    cv::Size winSize=cv::Size(20,20); // Lucas-Kanade optical flow window size                                                                                          \n    cv::TermCriteria termcrit=cv::TermCriteria(cv::TermCriteria::COUNT+cv::TermCriteria::EPS, 30, 0.01);\n\n    std::vector<uchar> status0;\n    std::vector<uchar> status1;\n    std::vector<uchar> status2;\n    std::vector<uchar> status3;\n\n    //clock_t tic = clock();\n    // sparse iterative version of the Lucas-Kanade optical flow in pyramids\n    calcOpticalFlowPyrLK(img_l_0, img_r_0, points_l_0, points_r_0, status0, err, winSize, 3, termcrit, cv::OPTFLOW_LK_GET_MIN_EIGENVALS, 0.01);\n    calcOpticalFlowPyrLK(img_r_0, img_r_1, points_r_0, points_r_1, status1, err, winSize, 3, termcrit, cv::OPTFLOW_LK_GET_MIN_EIGENVALS, 0.01);\n    calcOpticalFlowPyrLK(img_r_1, img_l_1, points_r_1, points_l_1, status2, err, winSize, 3, termcrit, cv::OPTFLOW_LK_GET_MIN_EIGENVALS, 0.01);\n    calcOpticalFlowPyrLK(img_l_1, img_l_0, points_l_1, points_l_0_return, status3, err, winSize, 3, termcrit, cv::OPTFLOW_LK_GET_MIN_EIGENVALS, 0.01);\n    //clock_t toc = clock();\n    //std::cerr << \"calcOpticalFlowPyrLK time: \" << float(toc - tic)/CLOCKS_PER_SEC*1000 << \"ms\" << std::endl;\n\n    deleteUnmatchFeaturesCircle(points_l_0, points_r_0, points_r_1, points_l_1, points_l_0_return,\n                        status0, status1, status2, status3, current_features);\n\n}\n\n#if USE_CUDA\nvoid circularMatching_gpu(cv::Mat img_l_0, cv::Mat img_r_0, cv::Mat img_l_1, cv::Mat img_r_1,\n                      std::vector<cv::Point2f>& points_l_0, std::vector<cv::Point2f>& points_r_0,\n                      std::vector<cv::Point2f>& points_l_1, std::vector<cv::Point2f>& points_r_1,\n                      std::vector<cv::Point2f>& points_l_0_return,\n                      FeatureSet& current_features) { \n  \n    //this function automatically gets rid of points for which tracking fails\n                    \n    cv::Size winSize=cv::Size(21,21);                                                                                             \n\n    std::vector<uchar> status0;\n    std::vector<uchar> status1;\n    std::vector<uchar> status2;\n    std::vector<uchar> status3;\n\n    clock_t tic_gpu = clock();\n    cv::Ptr<cv::cuda::SparsePyrLKOpticalFlow> d_pyrLK_sparse = cv::cuda::SparsePyrLKOpticalFlow::create(\n            winSize, 3, 30);\n    cv::cuda::GpuMat img_l_0_gpu(img_l_0);\n    cv::cuda::GpuMat img_r_0_gpu(img_r_0);\n    cv::cuda::GpuMat img_l_1_gpu(img_l_1);\n    cv::cuda::GpuMat img_r_1_gpu(img_r_1);\n    cv::cuda::GpuMat status0_gpu(status0);\n    cv::cuda::GpuMat status1_gpu(status1);\n    cv::cuda::GpuMat status2_gpu(status2);\n    cv::cuda::GpuMat status3_gpu(status3);\n    cv::cuda::GpuMat points_l_0_gpu(points_l_0);\n    cv::cuda::GpuMat points_r_0_gpu(points_r_0);\n    cv::cuda::GpuMat points_l_1_gpu(points_l_1);\n    cv::cuda::GpuMat points_r_1_gpu(points_r_1);\n    cv::cuda::GpuMat points_l_0_ret_gpu(points_l_0_return);\n\n    d_pyrLK_sparse->calc(img_l_0_gpu, img_r_0_gpu, points_l_0_gpu, points_r_0_gpu, status0_gpu);\n    d_pyrLK_sparse->calc(img_r_0_gpu, img_r_1_gpu, points_r_0_gpu, points_r_1_gpu, status1_gpu);\n    d_pyrLK_sparse->calc(img_r_1_gpu, img_l_1_gpu, points_r_1_gpu, points_l_1_gpu, status2_gpu);\n    d_pyrLK_sparse->calc(img_l_1_gpu, img_l_0_gpu, points_l_1_gpu, points_l_0_ret_gpu, status3_gpu);\n\n    download(status0_gpu, status0);\n    download(status1_gpu, status1);\n    download(status2_gpu, status2);\n    download(status3_gpu, status3);\n    download(points_l_0_gpu, points_l_0);\n    download(points_l_1_gpu, points_l_1);\n    download(points_r_0_gpu, points_r_0);\n    download(points_r_1_gpu, points_r_1);\n    download(points_l_0_ret_gpu, points_l_0_return);\n\n    clock_t toc_gpu = clock();\n    std::cerr << \"calcOpticalFlowPyrLK(CUDA)  time: \" << float(toc_gpu - tic_gpu)/CLOCKS_PER_SEC*1000 << \"ms\" << std::endl;\n\n    deleteUnmatchFeaturesCircle(points_l_0, points_r_0, points_r_1, points_l_1, points_l_0_return,\n                        status0, status1, status2, status3, current_features.ages);\n}\n#endif\n\n\nvoid displayTwoImages(const cv::Mat& image_1, const cv::Mat& image_2)\n{\n    cv::Size sz1 = image_1.size();\n    cv::Size sz2 = image_2.size();\n    cv::Mat image_3(sz1.height, sz1.width+sz2.width, CV_8UC1);\n    cv::Mat left(image_3, cv::Rect(0, 0, sz1.width, sz1.height));\n    image_1.copyTo(left);\n    cv::Mat right(image_3, cv::Rect(sz1.width, 0, sz2.width, sz2.height));\n    image_2.copyTo(right);\n    cv::imshow(\"im3\", image_3);\n    cv::waitKey(1);\n\n}\n\nvoid displayPoints(const cv::Mat& image, const std::vector<cv::Point2f>&  points)\n{\n    int radius = 2;\n    cv::Mat vis;\n\n    cv::cvtColor(image, vis, cv::COLOR_GRAY2BGR, 3);\n\n    for (int i = 0; i < points.size(); i++)\n    {\n        cv::circle(vis, cv::Point(points[i].x, points[i].y), radius, CV_RGB(0,255,0));\n    }\n\n    cv::imshow(\"vis \", vis );  \n    cv::waitKey(1);\n}\n\nvoid displayTracking(const cv::Mat& imageLeft_t1, \n                     const std::vector<cv::Point2f>&  pointsLeft_t0,\n                     const std::vector<cv::Point2f>&  pointsLeft_t1)\n{\n    // -----------------------------------------\n    // Display feature racking\n    // -----------------------------------------\n    int radius = 2;\n    cv::Mat vis;\n\n    cv::cvtColor(imageLeft_t1, vis, cv::COLOR_GRAY2BGR, 3);\n\n    for (int i = 0; i < pointsLeft_t0.size(); i++)\n    {\n      cv::circle(vis, cv::Point(pointsLeft_t0[i].x, pointsLeft_t0[i].y), radius, CV_RGB(0,255,0));\n    }\n\n    for (int i = 0; i < pointsLeft_t1.size(); i++)\n    {\n      cv::circle(vis, cv::Point(pointsLeft_t1[i].x, pointsLeft_t1[i].y), radius, CV_RGB(255,0,0));\n    }\n\n    for (int i = 0; i < pointsLeft_t1.size(); i++)\n    {\n      cv::line(vis, pointsLeft_t0[i], pointsLeft_t1[i], CV_RGB(0,255,0));\n    }\n\n    cv::imshow(\"vis \", vis );  \n    cv::waitKey(1);\n}"
        }
    ]
}