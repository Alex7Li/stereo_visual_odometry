{
    "sourceFile": "src/feature_set.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 130,
            "patches": [
                {
                    "date": 1647548914941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1647548973666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n #include \"../include/vo.h\"\n-namespace visual_odometry {\n+using namespace visual_odometry;\n+\n Bucket::Bucket(int size) { max_size = size; }\n \n Bucket::~Bucket() {}\n \n@@ -121,5 +122,4 @@\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n         }\n     }\n }\n-} // namespace visual_odometry\n"
                },
                {
                    "date": 1647550531085,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n     }\n   }\n }\n \n-std::vector<cv::Point2f> featureDetectionFast(const cv::Mat image, std::vector<float> & response_strength) {\n+std::vector<cv::Point2f> visual_odometry::featureDetectionFast(const cv::Mat image, std::vector<float> & response_strength) {\n   std::vector<cv::Point2f> points;\n   std::vector<cv::KeyPoint> keypoints;\n   bool nonmaxSuppression = true;\n   cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n"
                },
                {
                    "date": 1647640909939,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,8 @@\n     int image_height = image.rows;\n     int image_width = image.cols;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n-    int buckets_number = buckets_nums_height * buckets_nums_width;\n \n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n@@ -98,9 +97,9 @@\n     }\n \n     /* Put all current features into buckets by their location and scores */\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n-    for (int i = 0; i < points.size(); ++i)\n+    for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         buckets_nums_height_idx = points[i].y/bucket_size;\n         buckets_nums_width_idx = points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n"
                },
                {
                    "date": 1647640918611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n   bool nonmaxSuppression = true;\n   cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n   response_strength.reserve(points.size());\n-  for (const auto keypoint : keypoints) {\n+  for (const auto &keypoint : keypoints) {\n     response_strength.push_back(keypoint.response); \n   }\n   return points;\n }\n"
                },
                {
                    "date": 1647641167055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,9 +62,12 @@\n \n void FeatureSet::appendFeaturesFromImage(const cv::Mat & image) {\n     /* Fast feature detection */\n     std::vector<float>  response_strength;\n+    \n+    std::cout << \"aa\" << std::endl;\n     std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n+    std::cout << \"ab\" << std::endl;\n \n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n"
                },
                {
                    "date": 1647641199232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,8 +52,9 @@\n   std::vector<cv::KeyPoint> keypoints;\n   bool nonmaxSuppression = true;\n   cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n+  std::cout << \"aaa\" << std::endl;\n   response_strength.reserve(points.size());\n   for (const auto &keypoint : keypoints) {\n     response_strength.push_back(keypoint.response); \n   }\n"
                },
                {
                    "date": 1647641210957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,12 +50,15 @@\n std::vector<cv::Point2f> visual_odometry::featureDetectionFast(const cv::Mat image, std::vector<float> & response_strength) {\n   std::vector<cv::Point2f> points;\n   std::vector<cv::KeyPoint> keypoints;\n   bool nonmaxSuppression = true;\n+  std::cout << \"aaa\" << std::endl;\n   cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n+  std::cout << \"aab\" << std::endl;\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n-  std::cout << \"aaa\" << std::endl;\n+  std::cout << \"aac\" << std::endl;\n   response_strength.reserve(points.size());\n+  std::cout << \"aad\" << std::endl;\n   for (const auto &keypoint : keypoints) {\n     response_strength.push_back(keypoint.response); \n   }\n   return points;\n"
                },
                {
                    "date": 1647641649426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,13 @@\n   std::vector<cv::Point2f> points;\n   std::vector<cv::KeyPoint> keypoints;\n   bool nonmaxSuppression = true;\n   std::cout << \"aaa\" << std::endl;\n+  try {\n   cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n+  } catch(const cv::Exception& ex){\n+    std::cout << ex.err;\n+  }\n   std::cout << \"aab\" << std::endl;\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n   std::cout << \"aac\" << std::endl;\n   response_strength.reserve(points.size());\n"
                },
                {
                    "date": 1647641658470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n   std::cout << \"aaa\" << std::endl;\n   try {\n   cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex){\n-    std::cout << ex.err;\n+    std::cout << ex.err << std::endl;\n   }\n   std::cout << \"aab\" << std::endl;\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n   std::cout << \"aac\" << std::endl;\n"
                },
                {
                    "date": 1647641687401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n   std::cout << \"aaa\" << std::endl;\n   try {\n   cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex){\n-    std::cout << ex.err << std::endl;\n+    std::cout << ex << std::endl;\n   }\n   std::cout << \"aab\" << std::endl;\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n   std::cout << \"aac\" << std::endl;\n"
                },
                {
                    "date": 1647641700576,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n   std::cout << \"aaa\" << std::endl;\n   try {\n   cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex){\n-    std::cout << ex << std::endl;\n+    std::cout << ex.err << std::endl;\n   }\n   std::cout << \"aab\" << std::endl;\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n   std::cout << \"aac\" << std::endl;\n"
                },
                {
                    "date": 1647641827442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n   std::vector<cv::KeyPoint> keypoints;\n   bool nonmaxSuppression = true;\n   std::cout << \"aaa\" << std::endl;\n   try {\n-  cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n+    cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex){\n     std::cout << ex.err << std::endl;\n   }\n   std::cout << \"aab\" << std::endl;\n"
                },
                {
                    "date": 1647641832783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n   bool nonmaxSuppression = true;\n   std::cout << \"aaa\" << std::endl;\n   try {\n     cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n-  } catch(const cv::Exception& ex){\n+  } catch(const cv::Exception& ex) {\n     std::cout << ex.err << std::endl;\n   }\n   std::cout << \"aab\" << std::endl;\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n"
                },
                {
                    "date": 1647642412019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,8 +52,9 @@\n   std::vector<cv::KeyPoint> keypoints;\n   bool nonmaxSuppression = true;\n   std::cout << \"aaa\" << std::endl;\n   try {\n+    std::cout << image;\n     cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex) {\n     std::cout << ex.err << std::endl;\n   }\n"
                },
                {
                    "date": 1647642466690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n   std::vector<cv::KeyPoint> keypoints;\n   bool nonmaxSuppression = true;\n   std::cout << \"aaa\" << std::endl;\n   try {\n-    std::cout << image;\n+    std::cout << image.rows << \" \" << image.cols << endl;\n     cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex) {\n     std::cout << ex.err << std::endl;\n   }\n"
                },
                {
                    "date": 1647642472569,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n   std::vector<cv::KeyPoint> keypoints;\n   bool nonmaxSuppression = true;\n   std::cout << \"aaa\" << std::endl;\n   try {\n-    std::cout << image.rows << \" \" << image.cols << endl;\n+    std::cout << image.rows << \" \" << image.cols << std::endl;\n     cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex) {\n     std::cout << ex.err << std::endl;\n   }\n"
                },
                {
                    "date": 1647642504443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n   std::vector<cv::KeyPoint> keypoints;\n   bool nonmaxSuppression = true;\n   std::cout << \"aaa\" << std::endl;\n   try {\n-    std::cout << image.rows << \" \" << image.cols << std::endl;\n+    std::cout << image.rows << \"  \" << image.cols << std::endl;\n     cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex) {\n     std::cout << ex.err << std::endl;\n   }\n"
                },
                {
                    "date": 1647642735774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,20 +50,14 @@\n std::vector<cv::Point2f> visual_odometry::featureDetectionFast(const cv::Mat image, std::vector<float> & response_strength) {\n   std::vector<cv::Point2f> points;\n   std::vector<cv::KeyPoint> keypoints;\n   bool nonmaxSuppression = true;\n-  std::cout << \"aaa\" << std::endl;\n   try {\n-    std::cout << image.rows << \"  \" << image.cols << std::endl;\n     cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex) {\n-    std::cout << ex.err << std::endl;\n   }\n-  std::cout << \"aab\" << std::endl;\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n-  std::cout << \"aac\" << std::endl;\n   response_strength.reserve(points.size());\n-  std::cout << \"aad\" << std::endl;\n   for (const auto &keypoint : keypoints) {\n     response_strength.push_back(keypoint.response); \n   }\n   return points;\n"
                },
                {
                    "date": 1647642763030,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,8 +53,9 @@\n   bool nonmaxSuppression = true;\n   try {\n     cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex) {\n+    //maybe the image is empty or something?\n   }\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n   response_strength.reserve(points.size());\n   for (const auto &keypoint : keypoints) {\n"
                },
                {
                    "date": 1647642786858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,9 +67,8 @@\n void FeatureSet::appendFeaturesFromImage(const cv::Mat & image) {\n     /* Fast feature detection */\n     std::vector<float>  response_strength;\n     \n-    std::cout << \"aa\" << std::endl;\n     std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n     std::cout << \"ab\" << std::endl;\n \n     points.insert(points.end(), points_new.begin(), points_new.end());\n"
                },
                {
                    "date": 1647642815663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,8 +91,9 @@\n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n     // initialize all the buckets\n+    std::cout << \"ac\" << std::endl;\n     for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height; buckets_idx_height++)\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width; buckets_idx_width++)\n         {\n"
                },
                {
                    "date": 1647642832144,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -101,8 +101,9 @@\n             if (buckets_idx_height > BUCKET_START_ROW) buckets.push_back(Bucket(FEATURES_PER_BUCKET));\n             else buckets.push_back(Bucket(0));\n         }\n     }\n+    std::cout << \"ad\" << std::endl;\n \n     /* Put all current features into buckets by their location and scores */\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n@@ -111,8 +112,9 @@\n         buckets_nums_width_idx = points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n+    std::cout << \"ae\" << std::endl;\n \n     /* Take features from buckets and put them back into the feature set */\n     ages.clear();\n     points.clear();\n"
                },
                {
                    "date": 1647642870790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,8 +75,9 @@\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n+    std::cout << BUCKETS_PER_AXIS << std::endl;\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n \n     filterByBucketLocation(image, bucket_size);\n"
                },
                {
                    "date": 1647642908311,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,10 +85,10 @@\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n-    int buckets_nums_height = image_height/bucket_size;\n-    int buckets_nums_width = image_width/bucket_size;\n+    int buckets_nums_height = image_height/max(1, bucket_size);\n+    int buckets_nums_width = image_width/max(1, bucket_size);\n \n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n"
                },
                {
                    "date": 1647642919596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,10 +85,10 @@\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n-    int buckets_nums_height = image_height/max(1, bucket_size);\n-    int buckets_nums_width = image_width/max(1, bucket_size);\n+    int buckets_nums_height = image_height/std::max(1, bucket_size);\n+    int buckets_nums_width = image_width/std::max(1, bucket_size);\n \n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n"
                },
                {
                    "date": 1647642943138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,12 +83,13 @@\n     filterByBucketLocation(image, bucket_size);\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n+    int bucket_size = std::max(1, bucket_size)\n     int image_height = image.rows;\n     int image_width = image.cols;\n-    int buckets_nums_height = image_height/std::max(1, bucket_size);\n-    int buckets_nums_width = image_width/std::max(1, bucket_size);\n+    int buckets_nums_height = image_height/bucket_size;\n+    int buckets_nums_width = image_width/bucket_size;\n \n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n"
                },
                {
                    "date": 1647642960738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,9 +83,9 @@\n     filterByBucketLocation(image, bucket_size);\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n-    int bucket_size = std::max(1, bucket_size)\n+    bucket_size = std::max(1, bucket_size);\n     int image_height = image.rows;\n     int image_width = image.cols;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n"
                },
                {
                    "date": 1647642977003,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n     std::cout << BUCKETS_PER_AXIS << std::endl;\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n \n-    filterByBucketLocation(image, bucket_size);\n+    filterByBucketLocation(image, std::max(1, bucket_size));\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n     bucket_size = std::max(1, bucket_size);\n"
                },
                {
                    "date": 1647643003386,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,9 +68,8 @@\n     /* Fast feature detection */\n     std::vector<float>  response_strength;\n     \n     std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n-    std::cout << \"ab\" << std::endl;\n \n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n@@ -83,9 +82,8 @@\n     filterByBucketLocation(image, std::max(1, bucket_size));\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n-    bucket_size = std::max(1, bucket_size);\n     int image_height = image.rows;\n     int image_width = image.cols;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n@@ -93,9 +91,8 @@\n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n     // initialize all the buckets\n-    std::cout << \"ac\" << std::endl;\n     for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height; buckets_idx_height++)\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width; buckets_idx_width++)\n         {\n@@ -103,9 +100,8 @@\n             if (buckets_idx_height > BUCKET_START_ROW) buckets.push_back(Bucket(FEATURES_PER_BUCKET));\n             else buckets.push_back(Bucket(0));\n         }\n     }\n-    std::cout << \"ad\" << std::endl;\n \n     /* Put all current features into buckets by their location and scores */\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n@@ -114,9 +110,8 @@\n         buckets_nums_width_idx = points[i].x/bucket_size;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n-    std::cout << \"ae\" << std::endl;\n \n     /* Take features from buckets and put them back into the feature set */\n     ages.clear();\n     points.clear();\n"
                },
                {
                    "date": 1647643490035,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,8 +54,9 @@\n   try {\n     cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex) {\n     //maybe the image is empty or something?\n+    cout << ex.err << endl;\n   }\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n   response_strength.reserve(points.size());\n   for (const auto &keypoint : keypoints) {\n"
                },
                {
                    "date": 1647643500201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n   try {\n     cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n   } catch(const cv::Exception& ex) {\n     //maybe the image is empty or something?\n-    cout << ex.err << endl;\n+    std::cout << ex.err << std::endl;\n   }\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n   response_strength.reserve(points.size());\n   for (const auto &keypoint : keypoints) {\n"
                },
                {
                    "date": 1647647827061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,8 +74,9 @@\n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n+    std::cout << \"SS\" << strengths.size() << std::endl;\n \n     std::cout << BUCKETS_PER_AXIS << std::endl;\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n"
                },
                {
                    "date": 1647647890940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,8 +81,9 @@\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n \n     filterByBucketLocation(image, std::max(1, bucket_size));\n+    std::cout << \"SS\" << strengths.size() << std::endl;\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n     int image_height = image.rows;\n"
                },
                {
                    "date": 1647647901825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,16 +74,17 @@\n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n-    std::cout << \"SS\" << strengths.size() << std::endl;\n+    std::cout << \"SS \" << strengths.size() << std::endl;\n \n     std::cout << BUCKETS_PER_AXIS << std::endl;\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n \n     filterByBucketLocation(image, std::max(1, bucket_size));\n-    std::cout << \"SS\" << strengths.size() << std::endl;\n+    std::cout << \"SS2 \" << ages.size() << std::endl;\n+    std::cout << \"SS2 \" << strengths.size() << std::endl;\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n     int image_height = image.rows;\n"
                },
                {
                    "date": 1647647937665,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,8 +23,9 @@\n     // Insert any feature before bucket is full.\n     if (size() < max_size) {\n       features.points.push_back(point);\n       features.ages.push_back(age);\n+      features.strengths.push_back(strength);\n     } else {\n         // Replace the feauture with the lowest score.\n         int score_min = compute_score(features.ages[0],features.strengths[0]);\n         int score_min_idx = 0;\n"
                },
                {
                    "date": 1647648038186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,17 +75,13 @@\n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n-    std::cout << \"SS \" << strengths.size() << std::endl;\n \n-    std::cout << BUCKETS_PER_AXIS << std::endl;\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n \n     filterByBucketLocation(image, std::max(1, bucket_size));\n-    std::cout << \"SS2 \" << ages.size() << std::endl;\n-    std::cout << \"SS2 \" << strengths.size() << std::endl;\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n     int image_height = image.rows;\n"
                },
                {
                    "date": 1647648067756,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,8 +76,12 @@\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n+    /*TODO: Coincidence that these are equal? */\n+    std::cout << \"SS \" << strengths.size() << std::endl;\n+    std::cout << BUCKETS_PER_AXIS << std::endl;\n+\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n \n     filterByBucketLocation(image, std::max(1, bucket_size));\n"
                },
                {
                    "date": 1647648106262,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,12 +76,8 @@\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n-    /*TODO: Coincidence that these are equal? */\n-    std::cout << \"SS \" << strengths.size() << std::endl;\n-    std::cout << BUCKETS_PER_AXIS << std::endl;\n-\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n \n     filterByBucketLocation(image, std::max(1, bucket_size));\n"
                },
                {
                    "date": 1647657741302,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-#include \"../include/vo.h\"\n+#include \"vo.h\"\n using namespace visual_odometry;\n \n Bucket::Bucket(int size) { max_size = size; }\n \n"
                },
                {
                    "date": 1648065130182,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n \n-    filterByBucketLocation(image, std::max(1, bucket_size));\n+    filterByBucketLocation(image, BUCKETS_PER_ROW, BUCKETS_PER_COL);\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n     int image_height = image.rows;\n"
                },
                {
                    "date": 1648065151608,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,13 +78,12 @@\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n-\n     filterByBucketLocation(image, BUCKETS_PER_ROW, BUCKETS_PER_COL);\n }\n \n-void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n+void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int BUCKETS_PER_ROW, const int BUCKETS_PER_COL) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n"
                },
                {
                    "date": 1648065161267,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,16 +76,16 @@\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n-    /* Bucketing features */\n-    const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n     filterByBucketLocation(image, BUCKETS_PER_ROW, BUCKETS_PER_COL);\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int BUCKETS_PER_ROW, const int BUCKETS_PER_COL) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n+    /* Bucketing features */\n+    const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n \n     std::vector<Bucket> buckets;\n"
                },
                {
                    "date": 1648065175678,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,11 +91,11 @@\n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n     // initialize all the buckets\n-    for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height <= BUCKETS_PER_ROW; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width <= BUCKETS_PER_COL; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n             if (buckets_idx_height > BUCKET_START_ROW) buckets.push_back(Bucket(FEATURES_PER_BUCKET));\n             else buckets.push_back(Bucket(0));\n"
                },
                {
                    "date": 1648065202198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,8 +86,9 @@\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n+    int bucket_size_row = BUCKETS_PER_ROW / image.rows;\n \n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n"
                },
                {
                    "date": 1648065216718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n-    int bucket_size_row = BUCKETS_PER_ROW / image.rows;\n+    int bucket_size_row = image_height / BUCKETS_PER_ROW;\n \n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n"
                },
                {
                    "date": 1648065230035,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,8 +87,9 @@\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n     int bucket_size_row = image_height / BUCKETS_PER_ROW;\n+    int bucket_size_width = image_height / BUCKETS_PER_ROW;\n \n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n@@ -106,10 +107,10 @@\n     /* Put all current features into buckets by their location and scores */\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n-        buckets_nums_height_idx = points[i].y/bucket_size;\n-        buckets_nums_width_idx = points[i].x/bucket_size;\n+        buckets_nums_height_idx = points[i].y/bucket_size_height;\n+        buckets_nums_width_idx = points[i].x/bucket_size_width;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n"
                },
                {
                    "date": 1648065271302,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,10 +86,10 @@\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n-    int bucket_size_row = image_height / BUCKETS_PER_ROW;\n-    int bucket_size_width = image_height / BUCKETS_PER_ROW;\n+    int bucket_height = image_height / BUCKETS_PER_ROW;\n+    int bucket_width = image_height / BUCKETS_PER_ROW;\n \n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n@@ -107,10 +107,10 @@\n     /* Put all current features into buckets by their location and scores */\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n-        buckets_nums_height_idx = points[i].y/bucket_size_height;\n-        buckets_nums_width_idx = points[i].x/bucket_size_width;\n+        buckets_nums_height_idx = points[i].y/bucket_height;\n+        buckets_nums_width_idx = points[i].x/bucket_width;\n         buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n"
                },
                {
                    "date": 1648065277287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,9 @@\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n     int bucket_height = image_height / BUCKETS_PER_ROW;\n-    int bucket_width = image_height / BUCKETS_PER_ROW;\n+    int bucket_width = image_height / BUCKETS_PER_COL;\n \n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n"
                },
                {
                    "date": 1648065308060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,10 +86,10 @@\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n     int buckets_nums_height = image_height/bucket_size;\n     int buckets_nums_width = image_width/bucket_size;\n-    int bucket_height = image_height / BUCKETS_PER_ROW;\n-    int bucket_width = image_height / BUCKETS_PER_COL;\n+    int bucket_height = (image_height + BUCKETS_PER_ROW - 1) / BUCKETS_PER_ROW;\n+    int bucket_width = (image_height + BUCKETS_PER_COL - 1) / BUCKETS_PER_COL;\n \n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n"
                },
                {
                    "date": 1648065319518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,10 +84,8 @@\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n-    int buckets_nums_height = image_height/bucket_size;\n-    int buckets_nums_width = image_width/bucket_size;\n     int bucket_height = (image_height + BUCKETS_PER_ROW - 1) / BUCKETS_PER_ROW;\n     int bucket_width = (image_height + BUCKETS_PER_COL - 1) / BUCKETS_PER_COL;\n \n     std::vector<Bucket> buckets;\n@@ -109,9 +107,9 @@\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         buckets_nums_height_idx = points[i].y/bucket_height;\n         buckets_nums_width_idx = points[i].x/bucket_width;\n-        buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n+        buckets_idx = buckets_nums_height_idx*BUCKETS_PER_ROW + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648065336820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,9 +107,9 @@\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         buckets_nums_height_idx = points[i].y/bucket_height;\n         buckets_nums_width_idx = points[i].x/bucket_width;\n-        buckets_idx = buckets_nums_height_idx*BUCKETS_PER_ROW + buckets_nums_width_idx;\n+        buckets_idx = buckets_nums_height_idx*BUCKETS_PER_COL + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648065383507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,11 +91,11 @@\n     std::vector<Bucket> buckets;\n \n     // TODO: Why are these <= rather than <???\n     // initialize all the buckets\n-    for (int buckets_idx_height = 0; buckets_idx_height <= BUCKETS_PER_ROW; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < BUCKETS_PER_ROW; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width <= BUCKETS_PER_COL; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < BUCKETS_PER_COL; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n             if (buckets_idx_height > BUCKET_START_ROW) buckets.push_back(Bucket(FEATURES_PER_BUCKET));\n             else buckets.push_back(Bucket(0));\n"
                },
                {
                    "date": 1648065394270,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,11 +115,11 @@\n     /* Take features from buckets and put them back into the feature set */\n     ages.clear();\n     points.clear();\n     strengths.clear();\n-    for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < BUCKETS_PER_ROW; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < BUCKETS_PER_COL; buckets_idx_width++)\n         {\n             buckets_idx = buckets_idx_height*buckets_nums_width + buckets_idx_width;\n             FeatureSet bucket_features = buckets[buckets_idx].features;\n             points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n"
                },
                {
                    "date": 1648065404060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -119,9 +119,9 @@\n     for (int buckets_idx_height = 0; buckets_idx_height < BUCKETS_PER_ROW; buckets_idx_height++)\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < BUCKETS_PER_COL; buckets_idx_width++)\n         {\n-            buckets_idx = buckets_idx_height*buckets_nums_width + buckets_idx_width;\n+            buckets_idx = buckets_idx_height*BUCKETS_PER_COL + buckets_idx_width;\n             FeatureSet bucket_features = buckets[buckets_idx].features;\n             points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             ages.insert(ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n"
                },
                {
                    "date": 1648065501983,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,9 +83,8 @@\n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int BUCKETS_PER_ROW, const int BUCKETS_PER_COL) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n-    const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n     int bucket_height = (image_height + BUCKETS_PER_ROW - 1) / BUCKETS_PER_ROW;\n     int bucket_width = (image_height + BUCKETS_PER_COL - 1) / BUCKETS_PER_COL;\n \n     std::vector<Bucket> buckets;\n"
                },
                {
                    "date": 1648065526696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n     filterByBucketLocation(image, BUCKETS_PER_ROW, BUCKETS_PER_COL);\n }\n \n-void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int BUCKETS_PER_ROW, const int BUCKETS_PER_COL) {\n+void FeatureSet::filterByBucketLocation(const cv::Mat & image) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     int bucket_height = (image_height + BUCKETS_PER_ROW - 1) / BUCKETS_PER_ROW;\n"
                },
                {
                    "date": 1648065532618,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n-    filterByBucketLocation(image, BUCKETS_PER_ROW, BUCKETS_PER_COL);\n+    filterByBucketLocation(image);\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image) {\n     int image_height = image.rows;\n"
                },
                {
                    "date": 1648065612390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,9 +88,8 @@\n     int bucket_width = (image_height + BUCKETS_PER_COL - 1) / BUCKETS_PER_COL;\n \n     std::vector<Bucket> buckets;\n \n-    // TODO: Why are these <= rather than <???\n     // initialize all the buckets\n     for (int buckets_idx_height = 0; buckets_idx_height < BUCKETS_PER_ROW; buckets_idx_height++)\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < BUCKETS_PER_COL; buckets_idx_width++)\n"
                },
                {
                    "date": 1648065652067,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n     filterByBucketLocation(image);\n }\n \n-void FeatureSet::filterByBucketLocation(const cv::Mat & image) {\n+void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int BUCKETS_PER_ROW, const int BUCKETS_PER_COL) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     int bucket_height = (image_height + BUCKETS_PER_ROW - 1) / BUCKETS_PER_ROW;\n"
                },
                {
                    "date": 1648065662580,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,21 +79,21 @@\n \n     filterByBucketLocation(image);\n }\n \n-void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int BUCKETS_PER_ROW, const int BUCKETS_PER_COL) {\n+void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n-    int bucket_height = (image_height + BUCKETS_PER_ROW - 1) / BUCKETS_PER_ROW;\n-    int bucket_width = (image_height + BUCKETS_PER_COL - 1) / BUCKETS_PER_COL;\n+    int bucket_height = (image_height + buckets_per_row - 1) / buckets_per_row;\n+    int bucket_width = (image_height + buckets_per_col - 1) / buckets_per_col;\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n-    for (int buckets_idx_height = 0; buckets_idx_height < BUCKETS_PER_ROW; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_row; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width < BUCKETS_PER_COL; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n             if (buckets_idx_height > BUCKET_START_ROW) buckets.push_back(Bucket(FEATURES_PER_BUCKET));\n             else buckets.push_back(Bucket(0));\n@@ -105,21 +105,21 @@\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         buckets_nums_height_idx = points[i].y/bucket_height;\n         buckets_nums_width_idx = points[i].x/bucket_width;\n-        buckets_idx = buckets_nums_height_idx*BUCKETS_PER_COL + buckets_nums_width_idx;\n+        buckets_idx = buckets_nums_height_idx*buckets_per_col + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n     ages.clear();\n     points.clear();\n     strengths.clear();\n-    for (int buckets_idx_height = 0; buckets_idx_height < BUCKETS_PER_ROW; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_row; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width < BUCKETS_PER_COL; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n         {\n-            buckets_idx = buckets_idx_height*BUCKETS_PER_COL + buckets_idx_width;\n+            buckets_idx = buckets_idx_height*buckets_per_col + buckets_idx_width;\n             FeatureSet bucket_features = buckets[buckets_idx].features;\n             points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             ages.insert(ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n"
                },
                {
                    "date": 1648065668688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n-    filterByBucketLocation(image);\n+    filterByBucketLocation(image, BUCKETS_PER_ROW, BUCKETS_PER_COL);\n }\n \n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col) {\n     int image_height = image.rows;\n"
                },
                {
                    "date": 1648065833161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,9 @@\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     int bucket_height = (image_height + buckets_per_row - 1) / buckets_per_row;\n-    int bucket_width = (image_height + buckets_per_col - 1) / buckets_per_col;\n+    int bucket_width = (image_width + buckets_per_col - 1) / buckets_per_col;\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n"
                },
                {
                    "date": 1648065974432,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,11 @@\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n     filterByBucketLocation(image, BUCKETS_PER_ROW, BUCKETS_PER_COL);\n }\n-\n+/* filterByBucketLocation with added parameters for testing */\n+void FeatureSet::filterByBucketLocationInteral(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row) {\n+}\n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n"
                },
                {
                    "date": 1648065996453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,10 +80,8 @@\n     filterByBucketLocation(image, BUCKETS_PER_ROW, BUCKETS_PER_COL);\n }\n /* filterByBucketLocation with added parameters for testing */\n void FeatureSet::filterByBucketLocationInteral(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row) {\n-}\n-void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     int bucket_height = (image_height + buckets_per_row - 1) / buckets_per_row;\n@@ -127,4 +125,7 @@\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n         }\n     }\n }\n+void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col) {\n+  filterByBucketLocationInteral(image, BUCKET_START_ROW, BUCKETS_PER_COL, BUCKET_START_ROW)\n+}\n"
                },
                {
                    "date": 1648066011547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n     std::vector<int>  ages_new(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n-    filterByBucketLocation(image, BUCKETS_PER_ROW, BUCKETS_PER_COL);\n+    filterByBucketLocation(image);\n }\n /* filterByBucketLocation with added parameters for testing */\n void FeatureSet::filterByBucketLocationInteral(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row) {\n     int image_height = image.rows;\n@@ -126,6 +126,6 @@\n         }\n     }\n }\n void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col) {\n-  filterByBucketLocationInteral(image, BUCKET_START_ROW, BUCKETS_PER_COL, BUCKET_START_ROW)\n+  filterByBucketLocationInteral(image, BUCKET_START_ROW, BUCKETS_PER_COL, BUCKET_START_ROW);\n }\n"
                },
                {
                    "date": 1648066067788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n     filterByBucketLocation(image);\n }\n /* filterByBucketLocation with added parameters for testing */\n-void FeatureSet::filterByBucketLocationInteral(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row) {\n+void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     int bucket_height = (image_height + buckets_per_row - 1) / buckets_per_row;\n@@ -125,7 +125,7 @@\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n         }\n     }\n }\n-void FeatureSet::filterByBucketLocation(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col) {\n-  filterByBucketLocationInteral(image, BUCKET_START_ROW, BUCKETS_PER_COL, BUCKET_START_ROW);\n+void FeatureSet::filterByBucketLocation(const cv::Mat & image) {\n+  filterByBucketLocationInternal(image, BUCKET_START_ROW, BUCKETS_PER_COL, BUCKET_START_ROW);\n }\n"
                },
                {
                    "date": 1648066308847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,9 @@\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n-            if (buckets_idx_height > BUCKET_START_ROW) buckets.push_back(Bucket(FEATURES_PER_BUCKET));\n+            if (buckets_idx_height > bucket_start_row) buckets.push_back(Bucket(FEATURES_PER_BUCKET));\n             else buckets.push_back(Bucket(0));\n         }\n     }\n \n"
                },
                {
                    "date": 1648066316280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n \n     filterByBucketLocation(image);\n }\n /* filterByBucketLocation with added parameters for testing */\n-void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row) {\n+void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     int bucket_height = (image_height + buckets_per_row - 1) / buckets_per_row;\n"
                },
                {
                    "date": 1648066338944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,9 @@\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n-            if (buckets_idx_height > bucket_start_row) buckets.push_back(Bucket(FEATURES_PER_BUCKET));\n+            if (buckets_idx_height > bucket_start_row) buckets.push_back(Bucket(features_per_bucket));\n             else buckets.push_back(Bucket(0));\n         }\n     }\n \n"
                },
                {
                    "date": 1648066390849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,8 @@\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n     filterByBucketLocation(image);\n }\n-/* filterByBucketLocation with added parameters for testing */\n void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n@@ -126,6 +125,6 @@\n         }\n     }\n }\n void FeatureSet::filterByBucketLocation(const cv::Mat & image) {\n-  filterByBucketLocationInternal(image, BUCKET_START_ROW, BUCKETS_PER_COL, BUCKET_START_ROW);\n+  filterByBucketLocationInternal(image, BUCKET_START_ROW, BUCKETS_PER_COL, BUCKET_START_ROW, FEATURES_PER_BUCKET);\n }\n"
                },
                {
                    "date": 1648066461321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,6 +125,6 @@\n         }\n     }\n }\n void FeatureSet::filterByBucketLocation(const cv::Mat & image) {\n-  filterByBucketLocationInternal(image, BUCKET_START_ROW, BUCKETS_PER_COL, BUCKET_START_ROW, FEATURES_PER_BUCKET);\n+  filterByBucketLocationInternal(image, BUCKETS_PER_ROW, BUCKETS_PER_COL, BUCKET_START_ROW, FEATURES_PER_BUCKET);\n }\n"
                },
                {
                    "date": 1648067102059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,15 +82,15 @@\n void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n-    int bucket_height = (image_height + buckets_per_row - 1) / buckets_per_row;\n-    int bucket_width = (image_width + buckets_per_col - 1) / buckets_per_col;\n+    int bucket_height = (image_height + buckets_per_col - 1) / buckets_per_col;\n+    int bucket_width = (image_width + buckets_per_row - 1) / buckets_per_row;\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n-    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_row; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_col; buckets_idx_height++)\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n"
                },
                {
                    "date": 1648067113513,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,9 +88,9 @@\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n-    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_col; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_row; buckets_idx_height++)\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n"
                },
                {
                    "date": 1648067138572,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,8 +82,9 @@\n void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n+    // TODO: THink about this, is it backwards\n     int bucket_height = (image_height + buckets_per_col - 1) / buckets_per_col;\n     int bucket_width = (image_width + buckets_per_row - 1) / buckets_per_row;\n \n     std::vector<Bucket> buckets;\n"
                },
                {
                    "date": 1648067291804,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,9 +82,9 @@\n void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n-    // TODO: THink about this, is it backwards\n+    // TODO: Think about this, is it backwards?\n     int bucket_height = (image_height + buckets_per_col - 1) / buckets_per_col;\n     int bucket_width = (image_width + buckets_per_row - 1) / buckets_per_row;\n \n     std::vector<Bucket> buckets;\n"
                },
                {
                    "date": 1648067318809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,9 +104,9 @@\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         buckets_nums_height_idx = points[i].y/bucket_height;\n-        buckets_nums_width_idx = points[i].x/bucket_width;\n+        buckets_nums_width_idx = points[i].x/bucket_width; // TODO: x and y switched?\n         buckets_idx = buckets_nums_height_idx*buckets_per_col + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n"
                },
                {
                    "date": 1648068429315,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,22 +78,22 @@\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n     filterByBucketLocation(image);\n }\n-void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row, const int features_per_bucket) {\n+void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_each_col, const int buckets_each_row, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     // TODO: Think about this, is it backwards?\n-    int bucket_height = (image_height + buckets_per_col - 1) / buckets_per_col;\n-    int bucket_width = (image_width + buckets_per_row - 1) / buckets_per_row;\n+    int bucket_height = (image_height + buckets_each_row - 1) / buckets_each_row;\n+    int bucket_width = (image_width + buckets_each_col - 1) / buckets_each_col;\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n-    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_row; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_each_col; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < buckets_each_row; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n             if (buckets_idx_height > bucket_start_row) buckets.push_back(Bucket(features_per_bucket));\n             else buckets.push_back(Bucket(0));\n@@ -105,21 +105,21 @@\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         buckets_nums_height_idx = points[i].y/bucket_height;\n         buckets_nums_width_idx = points[i].x/bucket_width; // TODO: x and y switched?\n-        buckets_idx = buckets_nums_height_idx*buckets_per_col + buckets_nums_width_idx;\n+        buckets_idx = buckets_nums_height_idx*buckets_each_row + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n     ages.clear();\n     points.clear();\n     strengths.clear();\n-    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_row; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_each_col; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < buckets_each_row; buckets_idx_width++)\n         {\n-            buckets_idx = buckets_idx_height*buckets_per_col + buckets_idx_width;\n+            buckets_idx = buckets_idx_height*buckets_each_row + buckets_idx_width;\n             FeatureSet bucket_features = buckets[buckets_idx].features;\n             points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             ages.insert(ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n"
                },
                {
                    "date": 1648068441156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,9 +89,9 @@\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n-    for (int buckets_idx_height = 0; buckets_idx_height < buckets_each_col; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_each_row; buckets_idx_height++)\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_each_row; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n"
                },
                {
                    "date": 1648068528993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,22 +78,22 @@\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n     filterByBucketLocation(image);\n }\n-void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_each_col, const int buckets_each_row, const int bucket_start_row, const int features_per_bucket) {\n+void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     // TODO: Think about this, is it backwards?\n-    int bucket_height = (image_height + buckets_each_row - 1) / buckets_each_row;\n-    int bucket_width = (image_width + buckets_each_col - 1) / buckets_each_col;\n+    int bucket_height = (image_height + buckets_per_col - 1) / buckets_per_col;\n+    int bucket_width = (image_width + buckets_per_row - 1) / buckets_per_row;\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n-    for (int buckets_idx_height = 0; buckets_idx_height < buckets_each_row; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_row; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width < buckets_each_row; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n             if (buckets_idx_height > bucket_start_row) buckets.push_back(Bucket(features_per_bucket));\n             else buckets.push_back(Bucket(0));\n@@ -105,21 +105,21 @@\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         buckets_nums_height_idx = points[i].y/bucket_height;\n         buckets_nums_width_idx = points[i].x/bucket_width; // TODO: x and y switched?\n-        buckets_idx = buckets_nums_height_idx*buckets_each_row + buckets_nums_width_idx;\n+        buckets_idx = buckets_nums_height_idx*buckets_per_col + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n     ages.clear();\n     points.clear();\n     strengths.clear();\n-    for (int buckets_idx_height = 0; buckets_idx_height < buckets_each_col; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_row; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width < buckets_each_row; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n         {\n-            buckets_idx = buckets_idx_height*buckets_each_row + buckets_idx_width;\n+            buckets_idx = buckets_idx_height*buckets_per_col + buckets_idx_width;\n             FeatureSet bucket_features = buckets[buckets_idx].features;\n             points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             ages.insert(ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n"
                },
                {
                    "date": 1648068549422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,8 +83,9 @@\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     // TODO: Think about this, is it backwards?\n+    // round up\n     int bucket_height = (image_height + buckets_per_col - 1) / buckets_per_col;\n     int bucket_width = (image_width + buckets_per_row - 1) / buckets_per_row;\n \n     std::vector<Bucket> buckets;\n"
                },
                {
                    "date": 1648068661436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,14 +78,19 @@\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n     filterByBucketLocation(image);\n }\n+\n+int ceiling_division(int dividend, int divisor) {\n+    return (dividend + divisor - 1) / divisor;\n+}\n+\n void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     // TODO: Think about this, is it backwards?\n-    // round up\n+    // division round up\n     int bucket_height = (image_height + buckets_per_col - 1) / buckets_per_col;\n     int bucket_width = (image_width + buckets_per_row - 1) / buckets_per_row;\n \n     std::vector<Bucket> buckets;\n"
                },
                {
                    "date": 1648068684012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,11 +88,10 @@\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     // TODO: Think about this, is it backwards?\n-    // division round up\n-    int bucket_height = (image_height + buckets_per_col - 1) / buckets_per_col;\n-    int bucket_width = (image_width + buckets_per_row - 1) / buckets_per_row;\n+    int bucket_height = ceiling_division(image_height, buckets_per_col);\n+    int bucket_width = (image_width, buckets_per_row);\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n"
                },
                {
                    "date": 1648068712015,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,11 +87,10 @@\n void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n-    // TODO: Think about this, is it backwards?\n     int bucket_height = ceiling_division(image_height, buckets_per_col);\n-    int bucket_width = (image_width, buckets_per_row);\n+    int bucket_width = ceiling_division(image_width, buckets_per_row);\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n"
                },
                {
                    "date": 1648068784236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,9 +108,9 @@\n     int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         buckets_nums_height_idx = points[i].y/bucket_height;\n-        buckets_nums_width_idx = points[i].x/bucket_width; // TODO: x and y switched?\n+        buckets_nums_width_idx = points[i].x/bucket_width;\n         buckets_idx = buckets_nums_height_idx*buckets_per_col + buckets_nums_width_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n"
                },
                {
                    "date": 1648069136757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,47 +83,47 @@\n int ceiling_division(int dividend, int divisor) {\n     return (dividend + divisor - 1) / divisor;\n }\n \n-void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_per_row, const int buckets_per_col, const int bucket_start_row, const int features_per_bucket) {\n+void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_along_height, const int buckets_along_width, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n-    int bucket_height = ceiling_division(image_height, buckets_per_col);\n-    int bucket_width = ceiling_division(image_width, buckets_per_row);\n+    int bucket_height = ceiling_division(image_height, buckets_along_height);\n+    int bucket_width = ceiling_division(image_width, buckets_along_width);\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n-    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_row; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_along_height; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < buckets_along_width; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n             if (buckets_idx_height > bucket_start_row) buckets.push_back(Bucket(features_per_bucket));\n             else buckets.push_back(Bucket(0));\n         }\n     }\n \n     /* Put all current features into buckets by their location and scores */\n-    int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n+    int buckets_row_idx, bucket_col_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n-        buckets_nums_height_idx = points[i].y/bucket_height;\n-        buckets_nums_width_idx = points[i].x/bucket_width;\n-        buckets_idx = buckets_nums_height_idx*buckets_per_col + buckets_nums_width_idx;\n+        buckets_row_idx = points[i].y/bucket_height;\n+        bucket_col_idx = points[i].x/bucket_width;\n+        buckets_idx = buckets_row_idx*buckets_along_width + bucket_col_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n     ages.clear();\n     points.clear();\n     strengths.clear();\n-    for (int buckets_idx_height = 0; buckets_idx_height < buckets_per_row; buckets_idx_height++)\n+    for (int buckets_idx_height = 0; buckets_idx_height < buckets_along_height; buckets_idx_height++)\n     {\n-        for (int buckets_idx_width = 0; buckets_idx_width < buckets_per_col; buckets_idx_width++)\n+        for (int buckets_idx_width = 0; buckets_idx_width < buckets_along_width; buckets_idx_width++)\n         {\n-            buckets_idx = buckets_idx_height*buckets_per_col + buckets_idx_width;\n+            buckets_idx = buckets_idx_height*buckets_along_width + buckets_idx_width;\n             FeatureSet bucket_features = buckets[buckets_idx].features;\n             points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             ages.insert(ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n"
                },
                {
                    "date": 1648069161865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,9 +109,9 @@\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         buckets_row_idx = points[i].y/bucket_height;\n         bucket_col_idx = points[i].x/bucket_width;\n-        buckets_idx = buckets_row_idx*buckets_along_width + bucket_col_idx;\n+        buckets_idx = buckets_row_idx*buckets_along_height + bucket_col_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648069193329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,14 +104,14 @@\n         }\n     }\n \n     /* Put all current features into buckets by their location and scores */\n-    int buckets_row_idx, bucket_col_idx, buckets_idx;\n+    int bucket_height_idx, bucket_row_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n-        buckets_row_idx = points[i].y/bucket_height;\n-        bucket_col_idx = points[i].x/bucket_width;\n-        buckets_idx = buckets_row_idx*buckets_along_height + bucket_col_idx;\n+        bucket_height_idx = points[i].y/bucket_height;\n+        bucket_row_idx = points[i].x/bucket_width;\n+        buckets_idx = bucket_height_idx*buckets_along_height + bucket_row_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648069204228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,9 +121,9 @@\n     for (int buckets_idx_height = 0; buckets_idx_height < buckets_along_height; buckets_idx_height++)\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_along_width; buckets_idx_width++)\n         {\n-            buckets_idx = buckets_idx_height*buckets_along_width + buckets_idx_width;\n+            buckets_idx = buckets_idx_height*buckets_along_height + buckets_idx_width;\n             FeatureSet bucket_features = buckets[buckets_idx].features;\n             points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             ages.insert(ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n"
                },
                {
                    "date": 1648069290697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,6 +130,6 @@\n         }\n     }\n }\n void FeatureSet::filterByBucketLocation(const cv::Mat & image) {\n-  filterByBucketLocationInternal(image, BUCKETS_PER_ROW, BUCKETS_PER_COL, BUCKET_START_ROW, FEATURES_PER_BUCKET);\n+  filterByBucketLocationInternal(image, BUCKETS_ALONG_HEIGHT, BUCKETS_ALONG_WIDTH, BUCKET_START_ROW, FEATURES_PER_BUCKET);\n }\n"
                },
                {
                    "date": 1648069326186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,9 +83,10 @@\n int ceiling_division(int dividend, int divisor) {\n     return (dividend + divisor - 1) / divisor;\n }\n \n-void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_along_height, const int buckets_along_width, const int bucket_start_row, const int features_per_bucket) {\n+void FeatureSet::filterByBucketLocationInternal(const cv::Mat & image, const int buckets_along_height,\n+  const int buckets_along_width, const int bucket_start_row, const int features_per_bucket) {\n     int image_height = image.rows;\n     int image_width = image.cols;\n     /* Bucketing features */\n     int bucket_height = ceiling_division(image_height, buckets_along_height);\n"
                },
                {
                    "date": 1648069830803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,8 +90,10 @@\n     int image_width = image.cols;\n     /* Bucketing features */\n     int bucket_height = ceiling_division(image_height, buckets_along_height);\n     int bucket_width = ceiling_division(image_width, buckets_along_width);\n+    dbg(bucket_height);\n+    dbg(bucket_width);\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n"
                },
                {
                    "date": 1648069954745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,10 +90,8 @@\n     int image_width = image.cols;\n     /* Bucketing features */\n     int bucket_height = ceiling_division(image_height, buckets_along_height);\n     int bucket_width = ceiling_division(image_width, buckets_along_width);\n-    dbg(bucket_height);\n-    dbg(bucket_width);\n \n     std::vector<Bucket> buckets;\n \n     // initialize all the buckets\n"
                },
                {
                    "date": 1648070228780,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,9 +99,9 @@\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_along_width; buckets_idx_width++)\n         {\n             // Ignore top rows of image.\n-            if (buckets_idx_height > bucket_start_row) buckets.push_back(Bucket(features_per_bucket));\n+            if (buckets_idx_height >= bucket_start_row) buckets.push_back(Bucket(features_per_bucket));\n             else buckets.push_back(Bucket(0));\n         }\n     }\n \n"
                },
                {
                    "date": 1648070279344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,8 +110,10 @@\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         bucket_height_idx = points[i].y/bucket_height;\n         bucket_row_idx = points[i].x/bucket_width;\n+        dbg(bucket_height_idx);\n+        dbg(bucket_row_idx);\n         buckets_idx = bucket_height_idx*buckets_along_height + bucket_row_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n"
                },
                {
                    "date": 1648070570080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,10 +108,10 @@\n     /* Put all current features into buckets by their location and scores */\n     int bucket_height_idx, bucket_row_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n-        bucket_height_idx = points[i].y/bucket_height;\n-        bucket_row_idx = points[i].x/bucket_width;\n+        bucket_height_idx = points[i].x/bucket_height;\n+        bucket_row_idx = points[i].y/bucket_width;\n         dbg(bucket_height_idx);\n         dbg(bucket_row_idx);\n         buckets_idx = bucket_height_idx*buckets_along_height + bucket_row_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n"
                },
                {
                    "date": 1648070582526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,10 +108,10 @@\n     /* Put all current features into buckets by their location and scores */\n     int bucket_height_idx, bucket_row_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n-        bucket_height_idx = points[i].x/bucket_height;\n-        bucket_row_idx = points[i].y/bucket_width;\n+        bucket_height_idx = points[i].y/bucket_height;\n+        bucket_row_idx = points[i].x/bucket_width;\n         dbg(bucket_height_idx);\n         dbg(bucket_row_idx);\n         buckets_idx = bucket_height_idx*buckets_along_height + bucket_row_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n"
                },
                {
                    "date": 1648070628104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,10 +110,8 @@\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         bucket_height_idx = points[i].y/bucket_height;\n         bucket_row_idx = points[i].x/bucket_width;\n-        dbg(bucket_height_idx);\n-        dbg(bucket_row_idx);\n         buckets_idx = bucket_height_idx*buckets_along_height + bucket_row_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n"
                },
                {
                    "date": 1648070695509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,8 +110,10 @@\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         bucket_height_idx = points[i].y/bucket_height;\n         bucket_row_idx = points[i].x/bucket_width;\n+        dbg(bucket_height_idx);\n+        dbg(bucket_row_idx);\n         buckets_idx = bucket_height_idx*buckets_along_height + bucket_row_idx;\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n"
                },
                {
                    "date": 1648070725964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,8 +113,9 @@\n         bucket_row_idx = points[i].x/bucket_width;\n         dbg(bucket_height_idx);\n         dbg(bucket_row_idx);\n         buckets_idx = bucket_height_idx*buckets_along_height + bucket_row_idx;\n+        dbg(buckets_idx);\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648071141889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,9 +103,9 @@\n             if (buckets_idx_height >= bucket_start_row) buckets.push_back(Bucket(features_per_bucket));\n             else buckets.push_back(Bucket(0));\n         }\n     }\n-\n+    dbg(buckets.size());\n     /* Put all current features into buckets by their location and scores */\n     int bucket_height_idx, bucket_row_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n@@ -126,8 +126,9 @@\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_along_width; buckets_idx_width++)\n         {\n             buckets_idx = buckets_idx_height*buckets_along_height + buckets_idx_width;\n+            dbg(buckets_idx);\n             FeatureSet bucket_features = buckets[buckets_idx].features;\n             points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             ages.insert(ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n"
                },
                {
                    "date": 1648071200455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,8 +17,9 @@\n   // If max size is none, we never add anything.\n   if (!max_size) return;\n \n   const int score = compute_score(age, strength);\n+  dbgstr(\"enter\");\n   // Don't add sufficently old Features\n   if (age < AGE_THRESHOLD) {\n     // Insert any feature before bucket is full.\n     if (size() < max_size) {\n"
                },
                {
                    "date": 1648071207288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,8 +25,9 @@\n     if (size() < max_size) {\n       features.points.push_back(point);\n       features.ages.push_back(age);\n       features.strengths.push_back(strength);\n+      dbgstr(\"exit\");\n     } else {\n         // Replace the feauture with the lowest score.\n         int score_min = compute_score(features.ages[0],features.strengths[0]);\n         int score_min_idx = 0;\n"
                },
                {
                    "date": 1648071223206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,9 +25,8 @@\n     if (size() < max_size) {\n       features.points.push_back(point);\n       features.ages.push_back(age);\n       features.strengths.push_back(strength);\n-      dbgstr(\"exit\");\n     } else {\n         // Replace the feauture with the lowest score.\n         int score_min = compute_score(features.ages[0],features.strengths[0]);\n         int score_min_idx = 0;\n"
                },
                {
                    "date": 1648071229597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,8 @@\n   // If max size is none, we never add anything.\n   if (!max_size) return;\n \n   const int score = compute_score(age, strength);\n-  dbgstr(\"enter\");\n   // Don't add sufficently old Features\n   if (age < AGE_THRESHOLD) {\n     // Insert any feature before bucket is full.\n     if (size() < max_size) {\n"
                },
                {
                    "date": 1648071279335,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,9 +103,8 @@\n             if (buckets_idx_height >= bucket_start_row) buckets.push_back(Bucket(features_per_bucket));\n             else buckets.push_back(Bucket(0));\n         }\n     }\n-    dbg(buckets.size());\n     /* Put all current features into buckets by their location and scores */\n     int bucket_height_idx, bucket_row_idx, buckets_idx;\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n"
                },
                {
                    "date": 1648071300862,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,9 +112,8 @@\n         bucket_row_idx = points[i].x/bucket_width;\n         dbg(bucket_height_idx);\n         dbg(bucket_row_idx);\n         buckets_idx = bucket_height_idx*buckets_along_height + bucket_row_idx;\n-        dbg(buckets_idx);\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n@@ -125,9 +124,8 @@\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_along_width; buckets_idx_width++)\n         {\n             buckets_idx = buckets_idx_height*buckets_along_height + buckets_idx_width;\n-            dbg(buckets_idx);\n             FeatureSet bucket_features = buckets[buckets_idx].features;\n             points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             ages.insert(ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n"
                },
                {
                    "date": 1648071357762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -111,9 +111,10 @@\n         bucket_height_idx = points[i].y/bucket_height;\n         bucket_row_idx = points[i].x/bucket_width;\n         dbg(bucket_height_idx);\n         dbg(bucket_row_idx);\n-        buckets_idx = bucket_height_idx*buckets_along_height + bucket_row_idx;\n+        buckets_idx = bucket_height_idx*buckets_along_width + bucket_row_idx;\n+        dbg(buckets_idx);\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n"
                },
                {
                    "date": 1648071383222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,12 +109,9 @@\n     for (unsigned int i = 0; i < points.size(); ++i)\n     {\n         bucket_height_idx = points[i].y/bucket_height;\n         bucket_row_idx = points[i].x/bucket_width;\n-        dbg(bucket_height_idx);\n-        dbg(bucket_row_idx);\n         buckets_idx = bucket_height_idx*buckets_along_width + bucket_row_idx;\n-        dbg(buckets_idx);\n         buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n     }\n \n     /* Take features from buckets and put them back into the feature set */\n@@ -124,9 +121,9 @@\n     for (int buckets_idx_height = 0; buckets_idx_height < buckets_along_height; buckets_idx_height++)\n     {\n         for (int buckets_idx_width = 0; buckets_idx_width < buckets_along_width; buckets_idx_width++)\n         {\n-            buckets_idx = buckets_idx_height*buckets_along_height + buckets_idx_width;\n+            buckets_idx = buckets_idx_height*buckets_along_width + buckets_idx_width;\n             FeatureSet bucket_features = buckets[buckets_idx].features;\n             points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n             ages.insert(ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n             strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n"
                },
                {
                    "date": 1648585241843,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n     std::cout << ex.err << std::endl;\n   }\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n   response_strength.reserve(points.size());\n-  for (const auto &keypoint : keypoints) {\n+  for (const auto keypoint : keypoints) {\n     response_strength.push_back(keypoint.response); \n   }\n   return points;\n }\n"
                },
                {
                    "date": 1648585252508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n     std::cout << ex.err << std::endl;\n   }\n   cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n   response_strength.reserve(points.size());\n-  for (const auto keypoint : keypoints) {\n+  for (const auto &keypoint : keypoints) {\n     response_strength.push_back(keypoint.response); \n   }\n   return points;\n }\n"
                },
                {
                    "date": 1648587085693,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,22 @@\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n     filterByBucketLocation(image);\n }\n+void FeatureSet::appendGridOfFeatures(const cv::Mat & image) {\n+    /* Fast feature detection */\n+    std::vector<float>  response_strength;\n+    \n+    std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n \n+    points.insert(points.end(), points_new.begin(), points_new.end());\n+    std::vector<int>  ages_new(points_new.size(), 0);\n+    ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n+    strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n+\n+    filterByBucketLocation(image);\n+}\n+\n int ceiling_division(int dividend, int divisor) {\n     return (dividend + divisor - 1) / divisor;\n }\n \n"
                },
                {
                    "date": 1648587181776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,8 +86,9 @@\n     std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n \n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n+    std::vector<int>  response_strength(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n     filterByBucketLocation(image);\n"
                },
                {
                    "date": 1648587246289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,8 +83,9 @@\n     /* Fast feature detection */\n     std::vector<float>  response_strength;\n     \n     std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n+    int point_rows = BUCKETS_ALONG_HEIGHT * FEATURES_PER_BUCKET;\n \n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     std::vector<int>  response_strength(points_new.size(), 0);\n"
                },
                {
                    "date": 1648587257296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,9 +83,9 @@\n     /* Fast feature detection */\n     std::vector<float>  response_strength;\n     \n     std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n-    int point_rows = BUCKETS_ALONG_HEIGHT * FEATURES_PER_BUCKET;\n+    int point_rows = BUCKETS_ALONG_HEIGHT * int(sqrt(FEATURES_PER_BUCKET));\n \n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     std::vector<int>  response_strength(points_new.size(), 0);\n"
                },
                {
                    "date": 1648587263417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,8 +84,9 @@\n     std::vector<float>  response_strength;\n     \n     std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n     int point_rows = BUCKETS_ALONG_HEIGHT * int(sqrt(FEATURES_PER_BUCKET));\n+    int point_cols = BUCKETS_ALONG_HEIGHT * int(sqrt(FEATURES_PER_BUCKET));\n \n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     std::vector<int>  response_strength(points_new.size(), 0);\n"
                },
                {
                    "date": 1648587271859,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,9 +84,9 @@\n     std::vector<float>  response_strength;\n     \n     std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n     int point_rows = BUCKETS_ALONG_HEIGHT * int(sqrt(FEATURES_PER_BUCKET));\n-    int point_cols = BUCKETS_ALONG_HEIGHT * int(sqrt(FEATURES_PER_BUCKET));\n+    int point_cols = BUCKETS_ALONG_WIDTH * int(sqrt(FEATURES_PER_BUCKET));\n \n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     std::vector<int>  response_strength(points_new.size(), 0);\n"
                },
                {
                    "date": 1648587308119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,12 +82,16 @@\n void FeatureSet::appendGridOfFeatures(const cv::Mat & image) {\n     /* Fast feature detection */\n     std::vector<float>  response_strength;\n     \n-    std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n     int point_rows = BUCKETS_ALONG_HEIGHT * int(sqrt(FEATURES_PER_BUCKET));\n     int point_cols = BUCKETS_ALONG_WIDTH * int(sqrt(FEATURES_PER_BUCKET));\n+    std::vector<cv::Point2f>  points_new(point_rows * point_cols);\n+    for(int row = 0; row < point_rows; row++) {\n+      for(int col = 0; col < point_cols; col++) {\n \n+      }\n+    }\n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     std::vector<int>  response_strength(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n"
                },
                {
                    "date": 1648587313428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,9 @@\n     int point_cols = BUCKETS_ALONG_WIDTH * int(sqrt(FEATURES_PER_BUCKET));\n     std::vector<cv::Point2f>  points_new(point_rows * point_cols);\n     for(int row = 0; row < point_rows; row++) {\n       for(int col = 0; col < point_cols; col++) {\n-\n+        \n       }\n     }\n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n"
                },
                {
                    "date": 1648587328731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,9 @@\n     int point_cols = BUCKETS_ALONG_WIDTH * int(sqrt(FEATURES_PER_BUCKET));\n     std::vector<cv::Point2f>  points_new(point_rows * point_cols);\n     for(int row = 0; row < point_rows; row++) {\n       for(int col = 0; col < point_cols; col++) {\n-        \n+        points_new[row + col * point_rows] \n       }\n     }\n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n"
                },
                {
                    "date": 1648587404029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -84,12 +84,14 @@\n     std::vector<float>  response_strength;\n     \n     int point_rows = BUCKETS_ALONG_HEIGHT * int(sqrt(FEATURES_PER_BUCKET));\n     int point_cols = BUCKETS_ALONG_WIDTH * int(sqrt(FEATURES_PER_BUCKET));\n+    int n_rows = image.rows;\n+    int n_cols = image.cols;\n     std::vector<cv::Point2f>  points_new(point_rows * point_cols);\n     for(int row = 0; row < point_rows; row++) {\n       for(int col = 0; col < point_cols; col++) {\n-        points_new[row + col * point_rows] \n+        points_new[row + col * point_rows] = cv::Point2f(1, 2);\n       }\n     }\n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n"
                },
                {
                    "date": 1648587451444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,8 +89,9 @@\n     int n_cols = image.cols;\n     std::vector<cv::Point2f>  points_new(point_rows * point_cols);\n     for(int row = 0; row < point_rows; row++) {\n       for(int col = 0; col < point_cols; col++) {\n+        int r = row / point_rows\n         points_new[row + col * point_rows] = cv::Point2f(1, 2);\n       }\n     }\n     points.insert(points.end(), points_new.begin(), points_new.end());\n"
                },
                {
                    "date": 1648587489097,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,9 +89,10 @@\n     int n_cols = image.cols;\n     std::vector<cv::Point2f>  points_new(point_rows * point_cols);\n     for(int row = 0; row < point_rows; row++) {\n       for(int col = 0; col < point_cols; col++) {\n-        int r = row / point_rows\n+        int r = (row * n_rows) / point_rows;\n+        int c = (col * n_cols) / point_cols;\n         points_new[row + col * point_rows] = cv::Point2f(1, 2);\n       }\n     }\n     points.insert(points.end(), points_new.begin(), points_new.end());\n"
                },
                {
                    "date": 1648587495327,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,9 +91,9 @@\n     for(int row = 0; row < point_rows; row++) {\n       for(int col = 0; col < point_cols; col++) {\n         int r = (row * n_rows) / point_rows;\n         int c = (col * n_cols) / point_cols;\n-        points_new[row + col * point_rows] = cv::Point2f(1, 2);\n+        points_new[row + col * point_rows] = cv::Point2f(r, c);\n       }\n     }\n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n"
                },
                {
                    "date": 1648587520239,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,9 +91,9 @@\n     for(int row = 0; row < point_rows; row++) {\n       for(int col = 0; col < point_cols; col++) {\n         int r = (row * n_rows) / point_rows;\n         int c = (col * n_cols) / point_cols;\n-        points_new[row + col * point_rows] = cv::Point2f(r, c);\n+        points_new[row + col * point_rows] = cv::Point2f(c, r);\n       }\n     }\n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n"
                },
                {
                    "date": 1648587569738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,10 +80,8 @@\n     filterByBucketLocation(image);\n }\n void FeatureSet::appendGridOfFeatures(const cv::Mat & image) {\n     /* Fast feature detection */\n-    std::vector<float>  response_strength;\n-    \n     int point_rows = BUCKETS_ALONG_HEIGHT * int(sqrt(FEATURES_PER_BUCKET));\n     int point_cols = BUCKETS_ALONG_WIDTH * int(sqrt(FEATURES_PER_BUCKET));\n     int n_rows = image.rows;\n     int n_cols = image.cols;\n"
                },
                {
                    "date": 1648587945042,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,9 +98,9 @@\n     std::vector<int>  response_strength(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n-    filterByBucketLocation(image);\n+    // filterByBucketLocation(image);\n }\n \n int ceiling_division(int dividend, int divisor) {\n     return (dividend + divisor - 1) / divisor;\n"
                },
                {
                    "date": 1648587992087,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,10 +80,10 @@\n     filterByBucketLocation(image);\n }\n void FeatureSet::appendGridOfFeatures(const cv::Mat & image) {\n     /* Fast feature detection */\n-    int point_rows = BUCKETS_ALONG_HEIGHT * int(sqrt(FEATURES_PER_BUCKET));\n-    int point_cols = BUCKETS_ALONG_WIDTH * int(sqrt(FEATURES_PER_BUCKET));\n+    int point_rows = 2 * BUCKETS_ALONG_HEIGHT * int(sqrt(FEATURES_PER_BUCKET));\n+    int point_cols = 2 * BUCKETS_ALONG_WIDTH * int(sqrt(FEATURES_PER_BUCKET));\n     int n_rows = image.rows;\n     int n_cols = image.cols;\n     std::vector<cv::Point2f>  points_new(point_rows * point_cols);\n     for(int row = 0; row < point_rows; row++) {\n"
                },
                {
                    "date": 1648588110656,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,8 +92,9 @@\n         int c = (col * n_cols) / point_cols;\n         points_new[row + col * point_rows] = cv::Point2f(c, r);\n       }\n     }\n+\n     points.insert(points.end(), points_new.begin(), points_new.end());\n     std::vector<int>  ages_new(points_new.size(), 0);\n     std::vector<int>  response_strength(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n"
                },
                {
                    "date": 1648602217346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,10 +94,10 @@\n       }\n     }\n \n     points.insert(points.end(), points_new.begin(), points_new.end());\n-    std::vector<int>  ages_new(points_new.size(), 0);\n-    std::vector<int>  response_strength(points_new.size(), 0);\n+    std::vector<int> ages_new(points_new.size(), 0);\n+    std::vector<int> response_strength(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n     // filterByBucketLocation(image);\n"
                },
                {
                    "date": 1648602307385,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,10 +94,10 @@\n       }\n     }\n \n     points.insert(points.end(), points_new.begin(), points_new.end());\n-    std::vector<int> ages_new(points_new.size(), 0);\n-    std::vector<int> response_strength(points_new.size(), 0);\n+    std::vector<int>  ages_new(points_new.size(), 0);\n+    std::vector<int>  response_strength(points_new.size(), 0);\n     ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n     strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n \n     // filterByBucketLocation(image);\n"
                }
            ],
            "date": 1647548914941,
            "name": "Commit-0",
            "content": "#include \"../include/vo.h\"\nnamespace visual_odometry {\nBucket::Bucket(int size) { max_size = size; }\n\nBucket::~Bucket() {}\n\nint Bucket::size() { return features.points.size(); }\n\n/* Score is an integer. Age is from 1-10. Strength goes up to 100. */\nint Bucket::compute_score(const int age, const int strength)\n{\n    return age + (strength - FAST_THRESHOLD)/20;\n}\n\nvoid Bucket::add_feature(const cv::Point2f point, const int age, const int strength) {\n  // If max size is none, we never add anything.\n  if (!max_size) return;\n\n  const int score = compute_score(age, strength);\n  // Don't add sufficently old Features\n  if (age < AGE_THRESHOLD) {\n    // Insert any feature before bucket is full.\n    if (size() < max_size) {\n      features.points.push_back(point);\n      features.ages.push_back(age);\n    } else {\n        // Replace the feauture with the lowest score.\n        int score_min = compute_score(features.ages[0],features.strengths[0]);\n        int score_min_idx = 0;\n        for (int i = 1; i < size(); i++)\n        {\n            const int current_score = compute_score(features.ages[i],features.strengths[i]);\n            if (current_score < score_min)\n            {\n                score_min = current_score;\n                score_min_idx = i;\n            }\n        }\n        if (score > score_min)\n        {\n            features.points[score_min_idx] = point;\n            features.ages[score_min_idx] = age;\n            features.strengths[score_min_idx] = strength;\n        }\n    }\n  }\n}\n\nstd::vector<cv::Point2f> featureDetectionFast(const cv::Mat image, std::vector<float> & response_strength) {\n  std::vector<cv::Point2f> points;\n  std::vector<cv::KeyPoint> keypoints;\n  bool nonmaxSuppression = true;\n  cv::FAST(image, keypoints, FAST_THRESHOLD, nonmaxSuppression);\n  cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n  response_strength.reserve(points.size());\n  for (const auto keypoint : keypoints) {\n    response_strength.push_back(keypoint.response); \n  }\n  return points;\n}\n\nvoid FeatureSet::appendFeaturesFromImage(const cv::Mat & image) {\n    /* Fast feature detection */\n    std::vector<float>  response_strength;\n    std::vector<cv::Point2f>  points_new = featureDetectionFast(image, response_strength);\n\n    points.insert(points.end(), points_new.begin(), points_new.end());\n    std::vector<int>  ages_new(points_new.size(), 0);\n    ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n    strengths.insert(strengths.end(), response_strength.begin(), response_strength.end());\n\n    /* Bucketing features */\n    const int bucket_size = std::min(image.rows,image.cols)/BUCKETS_PER_AXIS;\n\n    filterByBucketLocation(image, bucket_size);\n}\n\nvoid FeatureSet::filterByBucketLocation(const cv::Mat & image, const int bucket_size) {\n    int image_height = image.rows;\n    int image_width = image.cols;\n    int buckets_nums_height = image_height/bucket_size;\n    int buckets_nums_width = image_width/bucket_size;\n    int buckets_number = buckets_nums_height * buckets_nums_width;\n\n    std::vector<Bucket> buckets;\n\n    // TODO: Why are these <= rather than <???\n    // initialize all the buckets\n    for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height; buckets_idx_height++)\n    {\n        for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width; buckets_idx_width++)\n        {\n            // Ignore top rows of image.\n            if (buckets_idx_height > BUCKET_START_ROW) buckets.push_back(Bucket(FEATURES_PER_BUCKET));\n            else buckets.push_back(Bucket(0));\n        }\n    }\n\n    /* Put all current features into buckets by their location and scores */\n    int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n    for (int i = 0; i < points.size(); ++i)\n    {\n        buckets_nums_height_idx = points[i].y/bucket_size;\n        buckets_nums_width_idx = points[i].x/bucket_size;\n        buckets_idx = buckets_nums_height_idx*buckets_nums_width + buckets_nums_width_idx;\n        buckets[buckets_idx].add_feature(points[i], ages[i], strengths[i]);\n    }\n\n    /* Take features from buckets and put them back into the feature set */\n    ages.clear();\n    points.clear();\n    strengths.clear();\n    for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height; buckets_idx_height++)\n    {\n        for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width; buckets_idx_width++)\n        {\n            buckets_idx = buckets_idx_height*buckets_nums_width + buckets_idx_width;\n            FeatureSet bucket_features = buckets[buckets_idx].features;\n            points.insert(points.end(), bucket_features.points.begin(), bucket_features.points.end());\n            ages.insert(ages.end(), bucket_features.ages.begin(), bucket_features.ages.end());\n            strengths.insert(strengths.end(), bucket_features.strengths.begin(), bucket_features.strengths.end());\n        }\n    }\n}\n} // namespace visual_odometry\n"
        }
    ]
}