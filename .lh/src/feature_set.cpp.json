{
    "sourceFile": "src/feature_set.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1646257414991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1646258181580,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,9 +15,9 @@\n       features.ages.push_back(age);\n     } else {\n       // TODO: Isn't this backwards? Don't we want to remove the\n       // oldest feature? ~ Alex\n-\n+      \n       // Insert feature with old age and remove youngest one.\n       int age_min = features.ages[0];\n       int age_min_idx = 0;\n \n"
                }
            ],
            "date": 1646257414991,
            "name": "Commit-0",
            "content": "#include \"stereo_visual_odometry/vo.h\"\n\nBucket::Bucket(int size) { max_size = size; }\n\nBucket::~Bucket() {}\n\nint Bucket::size() { return features.points.size(); }\n\nvoid Bucket::add_feature(const cv::Point2f point, const int age) {\n  // Don't add sufficently old Features\n  if (age < AGE_THRESHOLD) {\n    // Insert any feature before bucket is full.\n    if (size() < max_size) {\n      features.points.push_back(point);\n      features.ages.push_back(age);\n    } else {\n      // TODO: Isn't this backwards? Don't we want to remove the\n      // oldest feature? ~ Alex\n\n      // Insert feature with old age and remove youngest one.\n      int age_min = features.ages[0];\n      int age_min_idx = 0;\n\n      for (int i = 0; i < size(); i++) {\n        if (age < age_min) {\n          age_min = age;\n          age_min_idx = i;\n        }\n      }\n      features.points[age_min_idx] = point;\n      features.ages[age_min_idx] = age;\n    }\n  }\n}\n\nstd::vector<cv::Point2f> featureDetectionFast(const cv::Mat image) {\n  std::vector<cv::Point2f> points;\n  std::vector<cv::KeyPoint> keypoints;\n  int fast_threshold = 20;\n  bool nonmaxSuppression = true;\n  cv::FAST(image, keypoints, fast_threshold, nonmaxSuppression);\n  cv::KeyPoint::convert(keypoints, points, std::vector<int>());\n  return points;\n}\n\nvoid FeatureSet::appendFeaturesFromImage(const cv::Mat & image) {\n  std::vector<cv::Point2f> points_new = featureDetectionFast(image);\n  points.insert(points.end(), points_new.begin(), points_new.end());\n  std::vector<int> ages_new(points_new.size(), 0);\n  ages.insert(ages.end(), ages_new.begin(), ages_new.end());\n}\n\nvoid FeatureSet::filterByBucketLocation(const cv::Mat & image,\n                        const int bucket_size, const int features_per_bucket) {\n  int image_height = image.rows;\n  int image_width = image.cols;\n  int buckets_nums_height = image_height / bucket_size;\n  int buckets_nums_width = image_width / bucket_size;\n  int buckets_number = buckets_nums_height * buckets_nums_width;\n\n  std::vector<Bucket> buckets(bucket_nums_height * bucket_nums_width,\n                  Bucket(features_per_bucket));\n\n  // bucket all current features into buckets by their location\n  int buckets_nums_height_idx, buckets_nums_width_idx, buckets_idx;\n  for (int i = 0; i < points.size(); ++i) {\n    buckets_nums_height_idx = points[i].y / bucket_size;\n    buckets_nums_width_idx = points[i].x / bucket_size;\n    buckets_idx =\n        buckets_nums_height_idx * buckets_nums_width + buckets_nums_width_idx;\n    buckets[buckets_idx].add_feature(points[i], ages[i]);\n  }\n\n  points.clear();\n  ages.clear();\n\n\n  for (int buckets_idx_height = 0; buckets_idx_height <= buckets_nums_height;\n        buckets_idx_height++) {\n    for (int buckets_idx_width = 0; buckets_idx_width <= buckets_nums_width;\n          buckets_idx_width++) {\n      buckets_idx =\n          buckets_idx_height * buckets_nums_width + buckets_idx_width;\n      bucket = buckets[buckets_idx];\n      points.insert(points.end(), features.points.begin(), features.points.end());\n      ages.insert(ages.end(), features.ages.begin(), features.ages.end());\n      }\n  }\n}\n"
        }
    ]
}